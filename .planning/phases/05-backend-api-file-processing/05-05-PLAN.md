---
phase: 05-backend-api-file-processing
plan: 05
type: execute
wave: 4
depends_on: [05-02]
files_modified:
  - server/src/routes/upload-results.ts
  - server/src/routes/job-status.ts
  - server/src/lib/schema-validator.ts
  - server/src/server.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - User can POST results.json to /api/upload-results and have it validated
    - Server validates schema_version, timestamp, options, results, summary fields
    - Invalid results.json returns 400 with validation error details
    - User can GET /api/jobs/:jobId to query job status after SSE disconnect
    - Completed jobs return full results via status endpoint
  artifacts:
    - path: "server/src/routes/upload-results.ts"
      provides: "POST /api/upload-results endpoint"
      exports: ["uploadResultsHandler"]
    - path: "server/src/routes/job-status.ts"
      provides: "GET /api/jobs/:jobId endpoint"
      exports: ["jobStatusHandler"]
    - path: "server/src/lib/schema-validator.ts"
      provides: "ResultsOutput schema validation"
      exports: ["validateResultsOutput"]
  key_links:
    - from: "server/src/routes/upload-results.ts"
      to: "server/src/lib/schema-validator.ts"
      via: "validate uploaded results.json"
      pattern: "validateResultsOutput|schemaValidator"
    - from: "server/src/routes/job-status.ts"
      to: "server/src/lib/job-queue.ts"
      via: "query job status by ID"
      pattern: "jobQueue\.getStatus"
    - from: "server/src/lib/schema-validator.ts"
      to: "packages/shared/src/types.ts"
      via: "validate against ResultsOutput type"
      pattern: "ResultsOutput|schemaVersion"
---

<objective>
Implement results.json upload endpoint with schema validation and job status query endpoint

Purpose: Allow users to upload existing results files and query job status after SSE disconnect
Output: Working POST /api/upload-results and GET /api/jobs/:jobId endpoints
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/05-backend-api-file-processing/05-CONTEXT.md
@.planning/phases/05-backend-api-file-processing/05-02-PLAN.md
@server/src/server.ts
@server/src/lib/job-queue.ts
@packages/shared/src/types.ts
@src/output/json.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create results schema validator</name>
  <files>server/src/lib/schema-validator.ts</files>
  <action>
    Create server/src/lib/schema-validator.ts with validation functions:

    1. **Import ResultsOutput from @epub-counter/shared** (already exists in shared package)

    2. **Create ValidationResult type:**
       ```typescript
       interface ValidationResult {
         valid: boolean;
         errors: string[];
       }
       ```

    3. **Create validateResultsOutput function:**
       ```typescript
       import { ResultsOutput } from '@epub-counter/shared';

       export function validateResultsOutput(data: unknown): ValidationResult {
         const errors: string[] = [];

         // Check if data is object
         if (typeof data !== 'object' || data === null) {
           return { valid: false, errors: ['Input must be an object'] };
         }

         const obj = data as Record<string, unknown>;

         // Validate schema_version
         if (typeof obj.schemaVersion !== 'string') {
           errors.push('Missing or invalid schema_version (must be string)');
         }

         // Validate timestamp
         if (typeof obj.timestamp !== 'string') {
           errors.push('Missing or invalid timestamp (must be ISO string)');
         }

         // Validate options
         if (typeof obj.options !== 'object' || obj.options === null) {
           errors.push('Missing or invalid options (must be object)');
         } else {
           const opts = obj.options as Record<string, unknown>;
           if (!Array.isArray(opts.tokenizers)) {
             errors.push('options.tokenizers must be an array');
           }
         }

         // Validate results array
         if (!Array.isArray(obj.results)) {
           errors.push('Missing or invalid results (must be array)');
         }

         // Validate summary object
         if (typeof obj.summary !== 'object' || obj.summary === null) {
           errors.push('Missing or invalid summary (must be object)');
         } else {
           const summary = obj.summary as Record<string, unknown>;
           if (typeof summary.total !== 'number') {
             errors.push('summary.total must be a number');
           }
           if (typeof summary.success !== 'number') {
             errors.push('summary.success must be a number');
           }
           if (typeof summary.failed !== 'number') {
             errors.push('summary.failed must be a number');
           }
         }

         return {
           valid: errors.length === 0,
           errors
         };
       }
       ```

    This validates the ResultsOutput structure without requiring external validation libraries.
  </action>
  <verify>grep -q "validateResultsOutput\|ValidationResult\|from '@epub-counter/shared'" server/src/lib/schema-validator.ts</verify>
  <done>Schema validator exists with validateResultsOutput function, importing ResultsOutput from shared package</done>
</task>

<task type="auto">
  <name>Task 2: Create job status query endpoint</name>
  <files>server/src/routes/job-status.ts</files>
  <action>
  Create server/src/routes/job-status.ts with:

  1. **Import** dependencies:
     - JobState from @epub-counter/shared
     - jobQueue from ../lib/job-queue.js

  2. **Create jobStatusHandler async function** that:
     - Registers GET /api/jobs/:jobId route
     - Gets job status from jobQueue.getStatus(jobId)
     - If job not found, return 404 with:
       ```typescript
       { error: { code: 'JOB_NOT_FOUND', message: 'Job not found' } }
       ```
     - If job found, return 200 with JobState including:
       - jobId, status, createdAt, completedAt
       - progress (if processing)
       - results (if completed)
       - error (if failed)

  Return the full JobState object from jobQueue (it already has all needed fields).

  Optionally add GET /api/jobs to list all jobs:
  - Return array of {jobId, status, createdAt} for all jobs
  </action>
  <verify>grep -q "'/api/jobs'\|jobStatusHandler" server/src/routes/job-status.ts</verify>
  <done>GET /api/jobs/:jobId endpoint returns job status with results when complete</done>
</task>

<task type="auto">
  <name>Task 3: Create upload-results endpoint</name>
  <files>server/src/routes/upload-results.ts</files>
  <action>
    Create server/src/routes/upload-results.ts with:

    1. **Import** dependencies:
     - ResultsOutput from @epub-counter/shared (already exists)
     - validateResultsOutput from ../lib/schema-validator.js

    2. **Create uploadResultsHandler async function** that:
     - Registers POST /api/upload-results route
     - Parses request body as JSON
     - Validates using validateResultsOutput()
     - If invalid, return 400 with:
       ```typescript
       {
         error: {
           code: 'INVALID_SCHEMA',
           message: 'Invalid results.json format',
           details: validationErrors
         }
       }
       ```
     - If valid, return 200 with:
       ```typescript
       {
         success: true,
         data: {
           message: 'Results validated successfully',
           resultsCount: data.results.length,
           summary: data.summary
         }
       }
       ```

    Use Fastify's built-in JSON parsing. No file upload needed - accept raw JSON body.

    Optionally add size limit (1MB) to prevent huge uploads:
    ```typescript
    fastify.addContentTypeParser('application/json', {
      bodyLimit: 1024 * 1024 // 1MB
    }, async (request, body) => {
      return JSON.parse(body as string);
    });
    ```
  </action>
  <verify>grep -q "'/api/upload-results'\|uploadResultsHandler" server/src/routes/upload-results.ts</verify>
  <done>POST /api/upload-results validates results.json and returns success/error</done>
</task>

<task type="auto">
  <name>Task 4: Register new routes in server</name>
  <files>server/src/server.ts</files>
  <action>
    Import and register the new routes in server/src/server.ts:

    ```typescript
    import { jobStatusHandler } from './routes/job-status.js'
    import { uploadResultsHandler } from './routes/upload-results.js'

    // After SSE registration:
    await fastify.register(jobStatusHandler)
    await fastify.register(uploadResultsHandler)
    ```

    Ensure routes are registered in order: health -> list-models -> process -> sse -> job-status -> upload-results
  </action>
  <verify>grep -E "jobStatusHandler|uploadResultsHandler" server/src/server.ts</verify>
  <done>Job status and upload-results endpoints are registered in Fastify server</done>
</task>

</tasks>

<verification>
1. Start server: npm run dev:server

2. Test job status with valid job:
   ```bash
   # Create a job
   JOB_ID=$(curl -s -X POST http://localhost:8787/api/process \
     -H "Content-Type: application/json" \
     -d '{"path":"./epubs","tokenizers":["gpt4"]}' | jq -r '.jobId')

   # Query status
   curl http://localhost:8787/api/jobs/$JOB_ID | jq '.'
   ```
   Should return job state with status (queued/processing/completed)

3. Test invalid job ID:
   ```bash
   curl http://localhost:8787/api/jobs/invalid-id | jq '.error'
   ```
   Should return 404 with JOB_NOT_FOUND

4. Test valid results upload:
   ```bash
   # If you have a results.json file:
   curl -X POST http://localhost:8787/api/upload-results \
     -H "Content-Type: application/json" \
     -d @results.json | jq '.'
   ```
   Should return success with resultsCount

5. Test invalid results upload:
   ```bash
   curl -X POST http://localhost:8787/api/upload-results \
     -H "Content-Type: application/json" \
     -d '{"invalid":"data"}' | jq '.error'
   ```
   Should return 400 with INVALID_SCHEMA and error details

6. Test missing required fields:
   ```bash
   curl -X POST http://localhost:8787/api/upload-results \
     -H "Content-Type: application/json" \
     -d '{"schemaVersion":"1.0"}' | jq '.error.details'
   ```
   Should list all missing fields
</verification>

<success_criteria>
- GET /api/jobs/:jobId returns 200 with JobState for valid job IDs
- GET /api/jobs/:jobId returns 404 with JOB_NOT_FOUND for invalid job IDs
- Job state includes status, progress, results, error as appropriate
- POST /api/upload-results returns 200 with success for valid results.json
- POST /api/upload-results returns 400 with INVALID_SCHEMA for invalid JSON
- Validation error details list all missing/invalid fields
- Both endpoints handle edge cases (null data, wrong types, missing fields)
</success_criteria>

<output>
After completion, create `.planning/phases/05-backend-api-file-processing/05-05-SUMMARY.md`
</output>
