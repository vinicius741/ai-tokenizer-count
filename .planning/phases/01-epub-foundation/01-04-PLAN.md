---
phase: 01-epub-foundation
plan: 04
type: execute
wave: 3
depends_on: [01-03]
files_modified:
  - src/errors/handler.ts
  - src/output/markdown.ts
  - src/output/json.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool continues processing remaining EPUBs when one file fails"
    - "Errors are logged to stderr console during processing"
    - "Errors are logged to errors.log file in output folder"
    - "Error summary displays after processing (total, successful, failed)"
    - "results.md file is created in ./results/ folder with processing results"
    - "results.json file is created in ./results/ folder with word_count per EPUB (OUT-04)"
    - "Output folder (./results/) is created if it doesn't exist"
  artifacts:
    - path: "src/errors/handler.ts"
      provides: "Error handling and continue-on-error logic"
      exports: ["processEpubsWithErrors", "ProcessingResult", "logError"]
    - path: "src/output/markdown.ts"
      provides: "Markdown report generation"
      exports: ["generateResultsMarkdown", "writeResultsFile"]
    - path: "src/output/json.ts"
      provides: "JSON output generation with word_count (OUT-04)"
      exports: ["generateJsonOutput", "writeJsonFile", "EpubJsonResult"]
    - path: "src/cli/index.ts"
      provides: "Updated CLI with error handling"
      contains: "processEpubsWithErrors integration, error summary display"
  key_links:
    - from: "src/errors/handler.ts"
      to: "src/cli/index.ts"
      via: "processEpubsWithErrors function replaces direct processing loop"
      pattern: "import.*processEpubsWithErrors"
    - from: "src/errors/handler.ts"
      to: "errors.log"
      via: "File system write to ./results/ folder"
      pattern: "fs\\.writeFile.*errors\\.log"
    - from: "src/output/markdown.ts"
      to: "results.md"
      via: "File system write to ./results/ folder"
      pattern: "fs\\.writeFile.*results\\.md"
    - from: "src/output/json.ts"
      to: "results.json"
      via: "File system write to ./results/ folder"
      pattern: "fs\\.writeFile.*results\\.json"
    - from: "src/cli/index.ts"
      to: "src/output/markdown.ts"
      via: "writeResultsFile call after processing"
      pattern: "writeResultsFile\\("
    - from: "src/cli/index.ts"
      to: "src/output/json.ts"
      via: "writeJsonFile call after processing"
      pattern: "writeJsonFile\\("
---

<objective>
Implement error handling with continue-on-error behavior, dual error logging (console + file), markdown summary generation, and JSON output with word_count per EPUB (OUT-04).

Purpose: Ensure the tool is robust against malformed EPUB files — when one file fails, processing continues for remaining files. Errors are logged both visibly (stderr) and persistently (errors.log). A markdown summary file and JSON file with word_count preserve results for later reference, satisfying OUT-04 requirement.

Output: CLI that handles errors gracefully, logs comprehensively, generates persistent results files (markdown + JSON with word_count).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-epub-foundation/01-CONTEXT.md
@.planning/phases/01-epub-foundation/01-RESEARCH.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement error handling and continue-on-error logic</name>
  <files>src/errors/handler.ts</files>
  <action>
Create src/errors/handler.ts with:

1. Export interface ProcessingResult:
   - successful: EpubResult[] (from table.ts)
   - failed: Array<{ file: string; error: string; suggestion?: string }>
   - total: number

2. Export interface ErrorLogEntry:
   - file: string
   - error: string
   - timestamp: string (ISO 8601)
   - suggestion?: string

3. Export async function logError(entry: ErrorLogEntry, outputDir: string): Promise<void>
   - Ensure outputDir exists using fs.mkdir(outputDir, { recursive: true })
   - Append to errors.log file (create if not exists)
   - Format: "[timestamp] ${entry.file}: ${entry.error}${entry.suggestion ? ' Suggestion: ' + entry.suggestion : ''}\n"
   - Use ./results/ as default outputDir per CFG-02

4. Export async function processEpubsWithErrors(filePaths: string[], verbose: boolean = false): Promise<ProcessingResult>
   - Initialize empty successful and failed arrays
   - For each filePath in filePaths:
     - try:
       - Parse: parseEpubFile(filePath)
       - Extract metadata: extractMetadata(result.info)
       - Extract text: extractText(result.sections)
       - Count words: countWords(text)
       - Add to successful array
     - catch (error):
       - Extract error message: error.message || 'Unknown error'
       - Generate suggestion if possible (e.g., "File may be corrupted or not a valid EPUB")
       - Create ErrorLogEntry with file, error, timestamp, suggestion
       - Log to stderr: console.error(`Error: ${entry.file} - ${entry.error}`)
       - Call logError(entry, './results')
       - Add to failed array
   - Return { successful, failed, total: filePaths.length }

Use Continue-on-Error Pattern from RESEARCH.md as reference.

Implement helpful error suggestions:
- "File may be corrupted or not a valid EPUB" for general parse errors
- "Check file permissions" for EACCES errors
- "File not found" for ENOENT errors

Note: Use ./results/ as output directory per CFG-02 requirement.
  </action>
  <verify>Test with malformed EPUB file — should log error to stderr and errors.log, continue processing remaining files</verify>
  <done>processEpubsWithErrors() processes all files, continues on error, logs to stderr and errors.log, returns success/failed arrays</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON output with word_count (OUT-04)</name>
  <files>src/output/json.ts</files>
  <action>
Create src/output/json.ts with:

1. Export interface EpubJsonResult:
   - filename: string
   - file_path: string (absolute path)
   - title: string
   - author: string
   - word_count: number (required by OUT-04)
   - language?: string
   - publisher?: string

2. Export interface JsonOutputOptions:
   - outputDir: string (default './results' per CFG-02)
   - filename: string (default 'results.json')

3. Export function generateJsonOutput(result: ProcessingResult, timestamp: string): object
   - Return object with structure:
     {
       generated_at: timestamp,
       summary: {
         total: result.total,
         successful: result.successful.length,
         failed: result.failed.length
       },
       epubs: result.successful.map(epub => ({
         filename: epub.filename,
         file_path: epub.file_path || epub.filename,
         title: epub.title,
         author: epub.author,
         word_count: epub.wordCount,  // OUT-04 requirement
         language: epub.language,
         publisher: epub.publisher
       })),
       failed: result.failed.map(f => ({
         file: f.file,
         error: f.error,
         suggestion: f.suggestion
       }))
     }

4. Export async function writeJsonFile(result: ProcessingResult, options?: JsonOutputOptions): Promise<string>
   - Default options: { outputDir: './results', filename: 'results.json' }
   - Ensure outputDir exists using fs.mkdir(outputDir, { recursive: true })
   - Generate JSON content: generateJsonOutput(result, new Date().toISOString())
   - Write to file: fs.writeFile(path.join(outputDir, filename), JSON.stringify(content, null, 2))
   - Return absolute path to written file

Note: Use ./results/ as default output directory per CFG-02 requirement.
  </action>
  <verify>Run CLI with sample EPUBs — should create ./results/results.json with word_count field for each EPUB</verify>
  <done>writeJsonFile() creates results.json with summary, epubs array (each with word_count), and failed array; word_count field present per OUT-04</done>
</task>

<task type="auto">
  <name>Task 3: Implement markdown results generation</name>
  <files>src/output/markdown.ts</files>
  <action>
Create src/output/markdown.ts with:

1. Export interface MarkdownOptions:
   - outputDir: string (default './results' per CFG-02)
   - filename: string (default 'results.md')

2. Export function generateResultsMarkdown(result: ProcessingResult, timestamp: string): string
   - Generate markdown with:
     - Header: "# EPUB Processing Results"
     - Timestamp: "Generated: {timestamp}"
     - Summary section: "## Summary\n- Total: {total}\n- Successful: {successful.length}\n- Failed: {failed.length}"
     - Successful section (if any): "## Successful EPUBs\n\n| Filename | Words | Title | Author |\n|----------|-------|-------|--------|\n{table rows}"
     - Failed section (if any): "## Failed EPUBs\n\n{list of failures with error messages}"
   - Return formatted markdown string

3. Export async function writeResultsFile(result: ProcessingResult, options?: MarkdownOptions): Promise<string>
   - Default options: { outputDir: './results', filename: 'results.md' }
   - Ensure outputDir exists using fs.mkdir(outputDir, { recursive: true })
   - Generate markdown content: generateResultsMarkdown(result, new Date().toISOString())
   - Write to file: fs.writeFile(path.join(outputDir, filename), content)
   - Return absolute path to written file

Format tables with standard GitHub Flavored Markdown table syntax.

Note: Use ./results/ as default output directory per CFG-02 requirement.
  </action>
  <verify>Run CLI with sample EPUBs — should create ./results/results.md with formatted summary, successful table, and failed list</verify>
  <done>writeResultsFile() creates results.md with summary statistics, successful EPUBs table, and failed EPUBs list with error details</done>
</task>

<task type="auto">
  <name>Task 4: Update CLI to use error handling and generate results files</name>
  <files>src/cli/index.ts</files>
  <action>
Update src/cli/index.ts:

1. Import processEpubsWithErrors from '../errors/handler.js'
2. Import writeResultsFile from '../output/markdown.js'
3. Import writeJsonFile from '../output/json.js'
4. Import path from 'path'

2. Modify processEpubs function:
   - Replace direct processing loop with: const result = await processEpubsWithErrors(allFiles, options.verbose)
   - Call displayResults(result.successful) to show successful EPUBs table
   - Generate and write markdown results file: const mdPath = await writeResultsFile(result)
   - Generate and write JSON results file: const jsonPath = await writeJsonFile(result)
   - Display results file paths: console.log(`\nResults saved to:\n- ${mdPath}\n- ${jsonPath}`)
   - Display error summary:
     - console.log(`\nSummary:`)
     - console.log(`- Total EPUBs: ${result.total}`)
     - console.log(`- Successful: ${result.successful.length}`)
     - console.log(`- Failed: ${result.failed.length}`)
   - If verbose and failed.length > 0, list failed files

3. Handle "no EPUBs found" case:
   - If allFiles.length === 0, display message and exit gracefully
   - Don't create results files if no files were found

4. Ensure output directory (./results/) is created before any file writes

Note: Use ./results/ as output directory per CFG-02 requirement.
  </action>
  <verify>Run CLI with mix of valid and invalid EPUBs — should process all files, display error summary, create results.md and results.json with both successful and failed entries</verify>
  <done>CLI uses processEpubsWithErrors for robustness, displays error summary after processing, generates results.md and results.json files, handles empty EPUB list gracefully</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run build` compiles without errors
2. Running CLI with invalid EPUB continues processing
3. errors.log is created in ./results/ with error details
4. results.md is created in ./results/ with summary and tables
5. results.json is created in ./results/ with word_count field per EPUB (OUT-04)
6. Error summary displays in console after processing
</verification>

<success_criteria>
1. Malformed EPUB files don't crash the process
2. Errors appear in both stderr console and errors.log file
3. results.md contains summary statistics, successful table, and failed list
4. results.json contains summary, epubs array with word_count per EPUB (OUT-04), and failed array
5. Error summary shows total/successful/failed counts
6. Output directory ./results/ is created automatically if missing
7. All output uses ./results/ folder per CFG-02 requirement
</success_criteria>

<output>
After completion, create `.planning/phases/01-epub-foundation/01-04-SUMMARY.md`
</output>
