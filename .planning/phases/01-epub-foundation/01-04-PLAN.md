---
phase: 01-epub-foundation
plan: 04
type: execute
wave: 3
depends_on: [01-03]
files_modified:
  - src/errors/handler.ts
  - src/output/markdown.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool continues processing remaining EPUBs when one file fails"
    - "Errors are logged to stderr console during processing"
    - "Errors are logged to errors.log file in output folder"
    - "Error summary displays after processing (total, successful, failed)"
    - "results.md file is created in output folder with processing results"
    - "Output folder (./output/) is created if it doesn't exist"
  artifacts:
    - path: "src/errors/handler.ts"
      provides: "Error handling and continue-on-error logic"
      exports: ["processEpubsWithErrors", "ProcessingResult", "logError"]
    - path: "src/output/markdown.ts"
      provides: "Markdown report generation"
      exports: ["generateResultsMarkdown", "writeResultsFile"]
    - path: "src/cli/index.ts"
      provides: "Updated CLI with error handling"
      contains: "processEpubsWithErrors integration, error summary display"
  key_links:
    - from: "src/errors/handler.ts"
      to: "src/cli/index.ts"
      via: "processEpubsWithErrors function replaces direct processing loop"
      pattern: "import.*processEpubsWithErrors"
    - from: "src/errors/handler.ts"
      to: "errors.log"
      via: "File system write to output folder"
      pattern: "fs\\.writeFile.*errors\\.log"
    - from: "src/output/markdown.ts"
      to: "results.md"
      via: "File system write to output folder"
      pattern: "fs\\.writeFile.*results\\.md"
    - from: "src/cli/index.ts"
      to: "src/output/markdown.ts"
      via: "writeResultsFile call after processing"
      pattern: "writeResultsFile\\("
---

<objective>
Implement error handling with continue-on-error behavior, dual error logging (console + file), and results.md markdown summary generation.

Purpose: Ensure the tool is robust against malformed EPUB files — when one file fails, processing continues for remaining files. Errors are logged both visibly (stderr) and persistently (errors.log). A markdown summary file preserves results for later reference.

Output: CLI that handles errors gracefully, logs comprehensively, and generates persistent results file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-epub-foundation/01-CONTEXT.md
@.planning/phases/01-epub-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement error handling and continue-on-error logic</name>
  <files>src/errors/handler.ts</files>
  <action>
Create src/errors/handler.ts with:

1. Export interface ProcessingResult:
   - successful: EpubResult[] (from table.ts)
   - failed: Array<{ file: string; error: string; suggestion?: string }>
   - total: number

2. Export interface ErrorLogEntry:
   - file: string
   - error: string
   - timestamp: string (ISO 8601)
   - suggestion?: string

3. Export async function logError(entry: ErrorLogEntry, outputDir: string): Promise<void>
   - Ensure outputDir exists using fs.mkdir(outputDir, { recursive: true })
   - Append to errors.log file (create if not exists)
   - Format: "[timestamp] ${entry.file}: ${entry.error}${entry.suggestion ? ' Suggestion: ' + entry.suggestion : ''}\n"

4. Export async function processEpubsWithErrors(filePaths: string[], verbose: boolean = false): Promise<ProcessingResult>
   - Initialize empty successful and failed arrays
   - For each filePath in filePaths:
     - try:
       - Parse: parseEpubFile(filePath)
       - Extract metadata: extractMetadata(result.info)
       - Extract text: extractText(result.sections)
       - Count words: countWords(text)
       - Add to successful array
     - catch (error):
       - Extract error message: error.message || 'Unknown error'
       - Generate suggestion if possible (e.g., "File may be corrupted or not a valid EPUB")
       - Create ErrorLogEntry with file, error, timestamp, suggestion
       - Log to stderr: console.error(`Error: ${entry.file} - ${entry.error}`)
       - Call logError(entry, './output')
       - Add to failed array
   - Return { successful, failed, total: filePaths.length }

Use Continue-on-Error Pattern from RESEARCH.md as reference.

Implement helpful error suggestions:
- "File may be corrupted or not a valid EPUB" for general parse errors
- "Check file permissions" for EACCES errors
- "File not found" for ENOENT errors
  </action>
  <verify>Test with malformed EPUB file — should log error to stderr and errors.log, continue processing remaining files</verify>
  <done>processEpubsWithErrors() processes all files, continues on error, logs to stderr and errors.log, returns success/failed arrays</done>
</task>

<task type="auto">
  <name>Task 2: Implement markdown results generation</name>
  <files>src/output/markdown.ts</files>
<action>
Create src/output/markdown.ts with:

1. Export interface MarkdownOptions:
   - outputDir: string (default './output')
   - filename: string (default 'results.md')

2. Export function generateResultsMarkdown(result: ProcessingResult, timestamp: string): string
   - Generate markdown with:
     - Header: "# EPUB Processing Results"
     - Timestamp: "Generated: {timestamp}"
     - Summary section: "## Summary\n- Total: {total}\n- Successful: {successful.length}\n- Failed: {failed.length}"
     - Successful section (if any): "## Successful EPUBs\n\n| Filename | Words | Title | Author |\n|----------|-------|-------|--------|\n{table rows}"
     - Failed section (if any): "## Failed EPUBs\n\n{list of failures with error messages}"
   - Return formatted markdown string

3. Export async function writeResultsFile(result: ProcessingResult, options?: MarkdownOptions): Promise<string>
   - Default options: { outputDir: './output', filename: 'results.md' }
   - Ensure outputDir exists using fs.mkdir(outputDir, { recursive: true })
   - Generate markdown content: generateResultsMarkdown(result, new Date().toISOString())
   - Write to file: fs.writeFile(path.join(outputDir, filename), content)
   - Return absolute path to written file

Format tables with standard GitHub Flavored Markdown table syntax.
  </action>
  <verify>Run CLI with sample EPUBs — should create ./output/results.md with formatted summary, successful table, and failed list</verify>
  <done>writeResultsFile() creates results.md with summary statistics, successful EPUBs table, and failed EPUBs list with error details</done>
</task>

<task type="auto">
  <name>Task 3: Update CLI to use error handling and generate results file</name>
  <files>src/cli/index.ts</files>
  <action>
Update src/cli/index.ts:

1. Import processEpubsWithErrors from '../errors/handler.js'
2. Import writeResultsFile from '../output/markdown.js'
3. Import path from 'path'

2. Modify processEpubs function:
   - Replace direct processing loop with: const result = await processEpubsWithErrors(allFiles, options.verbose)
   - Call displayResults(result.successful) to show successful EPUBs table
   - Generate and write results file: const resultsPath = await writeResultsFile(result)
   - Display results file path: console.log(`\nResults saved to: ${resultsPath}`)
   - Display error summary:
     - console.log(`\nSummary:`)
     - console.log(`- Total EPUBs: ${result.total}`)
     - console.log(`- Successful: ${result.successful.length}`)
     - console.log(`- Failed: ${result.failed.length}`)
   - If verbose and failed.length > 0, list failed files

3. Handle "no EPUBs found" case:
   - If allFiles.length === 0, display message and exit gracefully
   - Don't create results file if no files were found

4. Ensure output directory is created before any file writes
  </action>
  <verify>Run CLI with mix of valid and invalid EPUBs — should process all files, display error summary, create results.md with both successful and failed entries</verify>
  <done>CLI uses processEpubsWithErrors for robustness, displays error summary after processing, generates results.md file, handles empty EPUB list gracefully</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run build` compiles without errors
2. Running CLI with invalid EPUB continues processing
3. errors.log is created in ./output/ with error details
4. results.md is created in ./output/ with summary and tables
5. Error summary displays in console after processing
</verification>

<success_criteria>
1. Malformed EPUB files don't crash the process
2. Errors appear in both stderr console and errors.log file
3. results.md contains summary statistics, successful table, and failed list
4. Error summary shows total/successful/failed counts
5. Output directory is created automatically if missing
</success_criteria>

<output>
After completion, create `.planning/phases/01-epub-foundation/01-04-SUMMARY.md`
</output>
