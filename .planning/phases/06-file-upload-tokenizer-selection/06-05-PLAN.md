---
phase: 06-file-upload-tokenizer-selection
plan: 05
type: execute
wave: 3
depends_on: [06-04]
files_modified:
  - web/src/components/tokenizer/TokenizerSelector.tsx
  - web/src/components/processing/ProcessButton.tsx
  - web/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can click Cancel button and see processing stop within 2 seconds"
    - "Cancel button only appears during processing (hidden when idle)"
    - "After cancel, UI shows cancelled state message"
    - "User can click Reset button to start new processing after cancel"
    - "Last selected tokenizers are saved to localStorage and restored on page load"
    - "Tokenizer selection persists across page refreshes"
    - "Reset button clears all state and returns to initial UI"
  artifacts:
    - path: "web/src/components/processing/ProcessButton.tsx"
      provides: "Process button with Cancel button during processing"
      exports: ["ProcessButton"]
    - path: "web/src/App.tsx"
      provides: "Main app with cancel/reset state management"
      min_lines: 150
  key_links:
    - from: "web/src/components/processing/ProcessButton.tsx"
      to: "web/src/hooks/use-sse-connection.ts"
      via: "disconnect function call"
      pattern: "disconnect.*abort"
    - from: "web/src/App.tsx"
      to: "web/src/components/tokenizer/TokenizerSelector.tsx"
      via: "localStorage persistence via useLocalStorage"
      pattern: "useLocalStorage.*selected-tokenizers"
---

<objective>
Add cancel processing functionality with abort controller, reset button, and ensure tokenizer selection persists to localStorage.

Purpose: Allow users to cancel processing mid-run, reset state, and maintain tokenizer preferences across sessions.

Output: Working cancel button, reset functionality, and localStorage persistence for tokenizer selection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-file-upload-tokenizer-selection/06-CONTEXT.md
@.planning/phases/06-file-upload-tokenizer-selection/06-RESEARCH.md

# Context Decisions
- "Cancel button shows only during processing" â€” Hidden when idle, appears when processing starts
- "After cancel, shows cancelled state; user must click Reset or New Process to continue"
- "Last selected tokenizers are remembered in localStorage, restored on page load"

# SSE Abort Pattern
- useSseConnection hook already has disconnect() function that calls abortController.abort()
- ProcessButton needs to expose onCancel callback
- App needs to manage cancelled state

# Backend Cancel Endpoint Requirement
- POST /api/cancel/:jobId endpoint is required to stop backend processing
- Frontend will call this endpoint when user clicks Cancel button
- If backend endpoint is not implemented yet, add to Phase 5 backend plans or implement as part of this phase
- Frontend should continue with cancel even if backend call fails (graceful degradation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ProcessButton to support Cancel button</name>
  <files>web/src/components/processing/ProcessButton.tsx</files>
  <action>
Update ProcessButton component to show Cancel button during processing:

```typescript
// web/src/components/processing/ProcessButton.tsx
import { useState } from 'react'
import { Loader2, X } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { toast } from 'sonner'

interface ProcessButtonProps {
  folderPath: string
  selectedTokenizers: string[]
  onJobStarted: (jobId: string) => void
  onCancel?: () => void
  disabled?: boolean
  isProcessing?: boolean
  jobId?: string // Added for cancel endpoint call
}

export function ProcessButton({
  folderPath,
  selectedTokenizers,
  onJobStarted,
  onCancel,
  disabled: externallyDisabled,
  isProcessing = false,
  jobId,
}: ProcessButtonProps) {
  const [isLoading, setIsLoading] = useState(false)

  const isDisabled =
    externallyDisabled ||
    !folderPath.trim() ||
    selectedTokenizers.length === 0 ||
    isLoading

  const handleClick = async () => {
    if (isDisabled) return

    setIsLoading(true)

    try {
      const response = await fetch('http://localhost:8787/api/process', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          inputPath: folderPath,
          tokenizerList: selectedTokenizers,
        }),
      })

      const data = await response.json()

      if (!response.ok || !data.success) {
        throw new Error(data.error?.message || 'Failed to start processing')
      }

      toast.success('Processing started', {
        description: `Job ID: ${data.data.jobId}`
      })

      onJobStarted(data.data.jobId)
    } catch (error) {
      toast.error('Failed to start processing', {
        description: error instanceof Error ? error.message : 'Unknown error'
      })
    } finally {
      setIsLoading(false)
    }
  }

  const handleCancel = async () => {
    // Call backend cancel endpoint if jobId is available
    if (jobId) {
      try {
        await fetch(`http://localhost:8787/api/cancel/${jobId}`, {
          method: 'POST',
        })
      } catch (error) {
        console.error('Failed to cancel backend job:', error)
        // Continue with frontend cancel even if backend call fails
      }
    }

    onCancel?.()
    toast.info('Processing cancelled', {
      description: 'Click Reset to start a new process'
    })
  }

  // Show Cancel button when processing
  if (isProcessing) {
    return (
      <Button
        onClick={handleCancel}
        variant="destructive"
        className="w-full"
        size="lg"
      >
        <X className="mr-2 h-4 w-4" />
        Cancel Processing
      </Button>
    )
  }

  // Show Process button when not processing
  return (
    <Button
      onClick={handleClick}
      disabled={isDisabled}
      className="w-full"
      size="lg"
    >
      {isLoading ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Starting...
        </>
      ) : (
        'Process EPUBs'
      )}
    </Button>
  )
}
```

Component should:
- Accept isProcessing prop to toggle between Process/Cancel buttons
- Accept jobId prop for backend cancel endpoint call
- Call POST /api/cancel/:jobId when Cancel clicked (if jobId available)
- Call onCancel callback after backend cancel attempt
- Show Cancel button with destructive variant when processing
- Show info toast after cancel
- Continue with frontend cancel even if backend cancel fails
  </action>
  <verify>web/src/components/processing/ProcessButton.tsx updated with Cancel button, isProcessing prop, jobId prop, and backend cancel endpoint call</verify>
  <done>ProcessButton now shows Cancel button during processing, calls backend cancel endpoint, and Process button when idle</done>
</task>

<task type="auto">
  <name>Task 2: Update useSseConnection to expose disconnect function</name>
  <files>web/src/hooks/use-sse-connection.ts</files>
  <action>
Update useSseConnection hook to return disconnect function that can be called externally:

```typescript
// web/src/hooks/use-sse-connection.ts
import { useCallback, useEffect, useRef } from 'react'
import { fetchEventSource } from '@microsoft/fetch-event-source'

export interface ProgressData {
  current: number
  total: number
  filename: string
  timestamp: string
}

export interface SseCallbacks {
  onProgress: (data: ProgressData) => void
  onComplete: (results: unknown) => void
  onError: (error: string) => void
}

export function useSseConnection() {
  const abortControllerRef = useRef<AbortController | null>(null)
  const callbacksRef = useRef<SseCallbacks | null>(null)

  const connect = useCallback(async (
    jobId: string,
    callbacks: SseCallbacks
  ) => {
    // Abort any existing connection
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
    }

    abortControllerRef.current = new AbortController()
    callbacksRef.current = callbacks

    const { onProgress, onComplete, onError } = callbacks

    try {
      await fetchEventSource(`http://localhost:8787/api/sse/${jobId}`, {
        method: 'GET',
        signal: abortControllerRef.current.signal,

        onopen(response) {
          if (response.ok && response.headers.get('content-type') === 'text/event-stream') {
            return
          }
          throw new Error(`Unexpected response: ${response.status}`)
        },

        onmessage(msg) {
          if (msg.event === 'progress') {
            const data = JSON.parse(msg.data) as ProgressData
            onProgress(data)
          } else if (msg.event === 'completed') {
            const results = JSON.parse(msg.data)
            onComplete(results)
          } else if (msg.event === 'error') {
            const error = JSON.parse(msg.data) as { message: string }
            onError(error.message)
          }
        },

        onerror(err) {
          onError(err.message)
          throw err
        },
      })
    } catch (error) {
      if (error instanceof Error && error.name !== 'AbortError') {
        onError(error.message)
      }
    }
  }, [])

  const disconnect = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort()
      abortControllerRef.current = null
    }
    callbacksRef.current = null
  }, [])

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      disconnect()
    }
  }, [disconnect])

  return { connect, disconnect, isConnected: () => abortControllerRef.current !== null }
}
```

Hook should:
- Expose disconnect function that can be called from parent component
- Track connection state via isConnected function
- Clean up refs on disconnect
  </action>
  <verify>web/src/hooks/use-sse-connection.ts updated to expose disconnect and isConnected functions</verify>
  <done>useSseConnection now exposes disconnect function for external cancellation</done>
</task>

<task type="auto">
  <name>Task 3: Update ProcessingProgress to expose disconnect ref</name>
  <files>web/src/components/progress/ProcessingProgress.tsx</files>
  <action>
Update ProcessingProgress component to expose disconnect function via ref:

```typescript
// web/src/components/progress/ProcessingProgress.tsx
import { useEffect, useState, useMemo, forwardRef, useImperativeHandle } from 'react'
import { Progress } from '@/components/ui/progress'
import { Clock, FileText } from 'lucide-react'
import { cn } from '@/lib/utils'
import { useSseConnection, type ProgressData } from '@/hooks/use-sse-connection'
import type { ResultsOutput } from '@epub-counter/shared'

export interface ProcessingProgressRef {
  disconnect: () => void
}

interface ProcessingProgressProps {
  jobId: string
  onComplete: (results: ResultsOutput) => void
}

export const ProcessingProgress = forwardRef<ProcessingProgressRef, ProcessingProgressProps>(
  ({ jobId, onComplete }, ref) => {
    const [progress, setProgress] = useState<ProgressData>({
      current: 0,
      total: 0,
      filename: '',
      timestamp: new Date().toISOString(),
    })
    const [startTime] = useState(() => Date.now())

    const percentage = progress.total > 0
      ? Math.round((progress.current / progress.total) * 100)
      : 0

    const eta = useMemo(() => {
      if (progress.current === 0 || progress.total === 0) return null

      const elapsed = Date.now() - startTime
      const avgTimePerEpub = elapsed / progress.current
      const remaining = progress.total - progress.current
      const etaMs = avgTimePerEpub * remaining

      const minutes = Math.floor(etaMs / 60000)
      const seconds = Math.floor((etaMs % 60000) / 1000)

      if (minutes > 0) {
        return `${minutes}m ${seconds}s remaining`
      }
      return `${seconds}s remaining`
    }, [progress.current, progress.total, startTime])

    const { connect, disconnect } = useSseConnection()

    // Expose disconnect function to parent via ref
    useImperativeHandle(ref, () => ({
      disconnect,
    }), [disconnect])

    useEffect(() => {
      connect(jobId, {
        onProgress: (data) => {
          setProgress(data)
        },
        onComplete: (results) => {
          onComplete(results as ResultsOutput)
        },
        onError: (error) => {
          console.error('SSE error:', error)
        },
      })
    }, [jobId, connect, onComplete])

    return (
      <div className="space-y-3 p-4 border rounded-lg bg-muted/30">
        <div className="space-y-2">
          <div className="flex items-center justify-between text-sm">
            <span className="font-medium">Processing EPUBs</span>
            <span className="text-muted-foreground">
              {progress.current} / {progress.total} ({percentage}%)
            </span>
          </div>

          <div className="relative">
            <Progress value={percentage} className="h-3" />
            {percentage > 0 && (
              <div
                className={cn(
                  "absolute inset-0 progress-striped rounded-full",
                  "opacity-50"
                )}
                style={{ width: `${percentage}%` }}
              />
            )}
          </div>
        </div>

        {progress.filename && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <FileText className="h-4 w-4 shrink-0" />
            <span className="truncate">{progress.filename}</span>
          </div>
        )}

        {eta && progress.current > 0 && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Clock className="h-4 w-4 shrink-0" />
            <span>{eta}</span>
          </div>
        )}
      </div>
    )
  }
)

ProcessingProgress.displayName = 'ProcessingProgress'
```

Component should:
- Use forwardRef to expose disconnect function to parent
- Use useImperativeHandle to properly expose the disconnect method
- Maintain existing functionality
  </action>
  <verify>web/src/components/progress/ProcessingProgress.tsx updated with forwardRef and useImperativeHandle</verify>
  <done>ProcessingProgress now exposes disconnect function via ref for external cancellation</done>
</task>

<task type="auto">
  <name>Task 4: Update App.tsx with cancel and reset functionality</name>
  <files>web/src/App.tsx</files>
<action>
Update App.tsx to handle cancel and reset with proper state management:

```typescript
// web/src/App.tsx
import { useState, useRef } from 'react'
import { RotateCcw } from 'lucide-react'
import { TokenizerSelector } from './components/tokenizer/TokenizerSelector'
import { FileDropzone } from './components/file-upload/FileDropzone'
import { FolderInput } from './components/processing/FolderInput'
import { ProcessButton } from './components/processing/ProcessButton'
import { ProcessingProgress, type ProcessingProgressRef } from './components/progress/ProcessingProgress'
import { CompletionSummary } from './components/progress/CompletionSummary'
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import type { ResultsOutput } from '@epub-counter/shared'

function App() {
  const [uploadedResults, setUploadedResults] = useState<ResultsOutput | null>(null)
  const [currentJobId, setCurrentJobId] = useState<string | null>(null)
  const [processingResults, setProcessingResults] = useState<ResultsOutput | null>(null)
  const [isCancelled, setIsCancelled] = useState(false)
  const [folderPath, setFolderPath] = useState('')
  const [selectedTokenizers, setSelectedTokenizers] = useState<string[]>([])

  const progressRef = useRef<ProcessingProgressRef>(null)

  const handleFileLoaded = (data: ResultsOutput, fileName: string) => {
    setUploadedResults(data)
    setProcessingResults(null)
    setIsCancelled(false)
    console.log('Uploaded results:', fileName, data)
  }

  const handleJobStarted = (jobId: string) => {
    setCurrentJobId(jobId)
    setProcessingResults(null)
    setIsCancelled(false)
    console.log('Job started:', jobId)
  }

  const handleProcessingComplete = (results: ResultsOutput) => {
    setProcessingResults(results)
    setCurrentJobId(null)
    setIsCancelled(false)
  }

  const handleCancel = () => {
    // Disconnect SSE connection
    progressRef.current?.disconnect()
    setCurrentJobId(null)
    setIsCancelled(true)
  }

  const handleReset = () => {
    // Reset all state
    setCurrentJobId(null)
    setProcessingResults(null)
    setUploadedResults(null)
    setIsCancelled(false)
    setFolderPath('')
    // Note: We don't reset selectedTokenizers to remember user preference
  }

  const isProcessing = !!currentJobId && !processingResults

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="max-w-2xl mx-auto space-y-6">
        <Card>
          <CardHeader>
            <CardTitle>EPUB Tokenizer Counter</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* Tokenizer Selection */}
            <div>
              <h2 className="text-lg font-semibold mb-4">1. Select Tokenizers</h2>
              <TokenizerSelector />
            </div>

            {/* File Upload OR Folder Input */}
            {!isProcessing && !processingResults && !isCancelled && (
              <div>
                <h2 className="text-lg font-semibold mb-4">2. Choose Input Source</h2>
                <div className="space-y-4">
                  <div>
                    <label className="text-sm font-medium mb-2 block">
                      Upload existing results.json
                    </label>
                    <FileDropzone onFileLoaded={handleFileLoaded} />
                  </div>

                  <div className="relative">
                    <div className="absolute inset-0 flex items-center">
                      <span className="w-full border-t" />
                    </div>
                    <div className="relative flex justify-center text-xs uppercase">
                      <span className="bg-background px-2 text-muted-foreground">
                        Or process new EPUBs
                      </span>
                    </div>
                  </div>

                  <div>
                    <label className="text-sm font-medium mb-2 block">
                      EPUB folder path (server-side)
                    </label>
                    <FolderInput
                      value={folderPath}
                      onChange={setFolderPath}
                    />
                  </div>
                </div>
              </div>
            )}

            {/* Process Button */}
            {!isProcessing && !processingResults && !isCancelled && (
              <div>
                <ProcessButton
                  folderPath={folderPath}
                  selectedTokenizers={selectedTokenizers}
                  onJobStarted={handleJobStarted}
                  onCancel={handleCancel}
                  isProcessing={false}
                />
              </div>
            )}

            {/* Progress Display */}
            {isProcessing && (
              <div>
                <h2 className="text-lg font-semibold mb-4">3. Processing Progress</h2>
                <ProcessingProgress
                  ref={progressRef}
                  jobId={currentJobId!}
                  onComplete={handleProcessingComplete}
                />

                {/* Cancel Button */}
                <div className="mt-4">
                  <ProcessButton
                    folderPath={folderPath}
                    selectedTokenizers={selectedTokenizers}
                    onJobStarted={handleJobStarted}
                    onCancel={handleCancel}
                    isProcessing={true}
                    jobId={currentJobId!}
                  />
                </div>
              </div>
            )}

            {/* Cancelled State */}
            {isCancelled && (
              <div className="space-y-4">
                <div className="p-4 border border-yellow-200 bg-yellow-50/50 dark:bg-yellow-950/20 rounded-lg">
                  <p className="text-sm text-yellow-800 dark:text-yellow-300">
                    Processing was cancelled. Click Reset to start a new process.
                  </p>
                </div>
                <Button
                  onClick={handleReset}
                  variant="outline"
                  className="w-full"
                >
                  <RotateCcw className="mr-2 h-4 w-4" />
                  Reset
                </Button>
              </div>
            )}

            {/* Completion Summary */}
            {processingResults && (
              <div className="space-y-4">
                <div>
                  <h2 className="text-lg font-semibold mb-4">Complete!</h2>
                  <CompletionSummary results={processingResults} />
                </div>

                {/* Reset Button */}
                <Button
                  onClick={handleReset}
                  variant="outline"
                  className="w-full"
                >
                  <RotateCcw className="mr-2 h-4 w-4" />
                  Process Another Batch
                </Button>
              </div>
            )}
          </CardContent>
        </Card>

        {/* Debug Info - Remove in production */}
        {currentJobId && (
          <Card>
            <CardContent className="pt-6">
              <p className="text-sm">Current Job ID: {currentJobId}</p>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  )
}

export default App
```

App should:
- Track isCancelled state separately
- Show cancelled state message after cancel
- Show Reset button after cancel or completion
- Call progressRef.current?.disconnect() on cancel
- Keep selectedTokenizers state on reset (remember preference)
- Hide input controls during processing
- Show Cancel button during processing
  </action>
  <verify>web/src/App.tsx updated with cancel, reset, and state management</verify>
  <done>App.tsx now handles cancel, reset, and maintains tokenizer selection persistence</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete cancel processing and reset functionality with localStorage persistence for tokenizer selection</what-built>
  <how-to-verify>
1. Start both servers: `npm run dev` from project root
2. Open http://localhost:5173 in browser
3. Test localStorage persistence:
   - Select GPT-4 and Claude tokenizers
   - Select a few HF models
   - Refresh the page
   - Verify all selections are restored (check UI and browser DevTools > Application > Local Storage)

4. Test cancel functionality:
   - Select tokenizers and enter folder path
   - Click "Process EPUBs" button
   - Wait for progress to start (progress bar appears)
   - Click "Cancel Processing" button
   - Verify SSE connection stops (check Network tab)
   - Verify cancelled state message appears
   - Verify "Reset" button appears
   - Verify process stops within 2 seconds

5. Test reset after cancel:
   - After seeing cancelled state, click "Reset" button
   - Verify UI returns to initial state
   - Verify tokenizer selections are still there (persisted)
   - Verify folder path is cleared

6. Test reset after completion:
   - Let a processing job complete
   - Verify CompletionSummary appears
   - Verify "Process Another Batch" button appears
   - Click "Process Another Batch"
   - Verify UI returns to initial state
   - Verify tokenizer selections persist

7. Test full workflow:
   - Select tokenizers
   - Enter path
   - Start processing
   - Cancel mid-way
   - Reset
   - Start new processing with same tokenizers
   - Let it complete
   - Reset again
   - Start another batch
  </how-to-verify>
  <resume-signal>Type "approved" if all features work, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. ProcessButton shows Cancel button during processing
2. Clicking Cancel calls disconnect() on SSE connection
3. Processing stops within 2 seconds of clicking Cancel
4. Cancelled state message appears after cancel
5. Reset button appears after cancel and completion
6. Clicking Reset clears all state except tokenizers
7. Tokenizer selections persist to localStorage
8. Tokenizer selections restore on page load
9. Input controls hide during processing
10. Reset button clears processing results
</verification>

<success_criteria>
Phase 6 Plan 5 is complete when:
1. User can click Cancel and see processing stop within 2 seconds
2. Cancel button only appears during processing
3. Cancel calls POST /api/cancel/:jobId to stop backend job
4. Frontend continues with cancel even if backend endpoint fails
5. Cancelled state message appears after cancel
6. Reset button appears after cancel/completion
7. Reset button clears all state except tokenizers
8. Tokenizer selections persist across page refreshes
9. localStorage key 'selected-tokenizers' contains saved selections
10. UI properly manages all states (idle, processing, cancelled, complete)
11. SSE connections properly abort on cancel
12. Full workflow (process -> cancel -> reset -> process) works smoothly
</success_criteria>

<output>
After completion, create `.planning/phases/06-file-upload-tokenizer-selection/06-05-SUMMARY.md`
</output>
