---
phase: 06-file-upload-tokenizer-selection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/file-upload/FileDropzone.tsx
  - web/src/components/file-upload/FileChip.tsx
  - web/src/lib/schema-validator.ts
autonomous: false

must_haves:
  truths:
    - "User can drag-and-drop results.json file into the drop zone"
    - "User can click drop zone to open file picker and select results.json"
    - "User sees visual feedback when dragging file over drop zone (zone expands)"
    - "UI validates uploaded file is valid JSON with correct schema"
    - "Validation errors (invalid JSON, wrong schema) shown as toasts that auto-dismiss"
    - "After file selection, zone shrinks to small chip showing filename with X button"
    - "Clicking X button removes the file and shows drop zone again"
  artifacts:
    - path: "web/src/components/file-upload/FileDropzone.tsx"
      provides: "Drag-drop file upload zone with visual feedback"
      min_lines: 80
    - path: "web/src/components/file-upload/FileChip.tsx"
      provides: "Compact file display chip with remove button"
      min_lines: 30
    - path: "web/src/lib/schema-validator.ts"
      provides: "Frontend schema validator for results.json"
      min_lines: 50
  key_links:
    - from: "web/src/components/file-upload/FileDropzone.tsx"
      to: "web/src/lib/schema-validator.ts"
      via: "import validateResultsFile"
      pattern: "validateResultsFile"
    - from: "web/src/components/file-upload/FileDropzone.tsx"
      to: "sonner toast"
      via: "import toast from 'sonner'"
      pattern: "toast\.(error|success)"
---

<objective>
Create file upload interface with drag-and-drop zone, file picker, and JSON schema validation for results.json files.

Purpose: Allow users to upload existing results.json files with visual feedback and proper validation.

Output: Working file dropzone with drag states, file picker, schema validation, and toast notifications.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-file-upload-tokenizer-selection/06-CONTEXT.md
@.planning/phases/06-file-upload-tokenizer-selection/06-RESEARCH.md
@.planning/phases/05-backend-api-file-processing/05-05-SUMMARY.md

# ResultsOutput Schema (from shared package)
- schemaVersion: "1.0"
- timestamp: ISO string
- options: object with tokenizerList, inputPath
- results: array with filePath, metadata, wordCount, tokenCounts
- summary: object with total, success, failed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create frontend schema validator for results.json</name>
  <files>web/src/lib/schema-validator.ts</files>
  <action>
Create schema validator for ResultsOutput type:

```typescript
// web/src/lib/schema-validator.ts
import type { ResultsOutput } from '@epub-counter/shared'

interface ValidationResult {
  valid: boolean
  errors: string[]
}

export function validateResultsOutput(data: unknown): data is ResultsOutput {
  const errors: string[] = []

  // Check if data is an object
  if (typeof data !== 'object' || data === null) {
    errors.push('Root must be an object')
    return false
  }

  const obj = data as Record<string, unknown>

  // Check schemaVersion
  if (!('schemaVersion' in obj) || typeof obj.schemaVersion !== 'string') {
    errors.push('Missing or invalid schemaVersion')
  } else if (obj.schemaVersion !== '1.0') {
    errors.push(`Unsupported schema version: ${obj.schemaVersion}`)
  }

  // Check timestamp
  if (!('timestamp' in obj) || typeof obj.timestamp !== 'string') {
    errors.push('Missing or invalid timestamp')
  }

  // Check options
  if (!('options' in obj) || typeof obj.options !== 'object' || obj.options === null) {
    errors.push('Missing or invalid options')
  } else {
    const options = obj.options as Record<string, unknown>
    if (!('tokenizerList' in options) || !Array.isArray(options.tokenizerList)) {
      errors.push('Missing or invalid tokenizerList in options')
    }
    if (!('inputPath' in options) || typeof options.inputPath !== 'string') {
      errors.push('Missing or invalid inputPath in options')
    }
  }

  // Check results
  if (!('results' in obj) || !Array.isArray(obj.results)) {
    errors.push('Missing or invalid results array')
  } else {
    obj.results.forEach((result, index) => {
      if (typeof result !== 'object' || result === null) {
        errors.push(`Result[${index}] must be an object`)
        return
      }
      const r = result as Record<string, unknown>
      if (!('filePath' in r) || typeof r.filePath !== 'string') {
        errors.push(`Result[${index}] missing filePath`)
      }
      if (!('metadata' in r) || typeof r.metadata !== 'object') {
        errors.push(`Result[${index}] missing metadata`)
      }
      if (!('wordCount' in r) || typeof r.wordCount !== 'number') {
        errors.push(`Result[${index}] missing or invalid wordCount`)
      }
      if (!('tokenCounts' in r) || typeof r.tokenCounts !== 'object') {
        errors.push(`Result[${index}] missing tokenCounts`)
      }
    })
  }

  // Check summary
  if (!('summary' in obj) || typeof obj.summary !== 'object' || obj.summary === null) {
    errors.push('Missing or invalid summary')
  } else {
    const summary = obj.summary as Record<string, unknown>
    if (!('total' in summary) || typeof summary.total !== 'number') {
      errors.push('Summary missing or invalid total')
    }
    if (!('success' in summary) || typeof summary.success !== 'number') {
      errors.push('Summary missing or invalid success')
    }
    if (!('failed' in summary) || typeof summary.failed !== 'number') {
      errors.push('Summary missing or invalid failed')
    }
  }

  return errors.length === 0
}

export function validateResultsFile(data: unknown): ValidationResult {
  const errors: string[] = []

  if (typeof data !== 'object' || data === null) {
    return { valid: false, errors: ['Root must be an object'] }
  }

  const obj = data as Record<string, unknown>

  // Check schemaVersion
  if (!('schemaVersion' in obj) || typeof obj.schemaVersion !== 'string') {
    errors.push('Missing or invalid schemaVersion')
  } else if (obj.schemaVersion !== '1.0') {
    errors.push(`Unsupported schema version: ${obj.schemaVersion}`)
  }

  // Check timestamp
  if (!('timestamp' in obj) || typeof obj.timestamp !== 'string') {
    errors.push('Missing or invalid timestamp')
  }

  // Check options
  if (!('options' in obj) || typeof obj.options !== 'object' || obj.options === null) {
    errors.push('Missing or invalid options')
  } else {
    const options = obj.options as Record<string, unknown>
    if (!('tokenizerList' in options) || !Array.isArray(options.tokenizerList)) {
      errors.push('Missing or invalid tokenizerList in options')
    }
    if (!('inputPath' in options) || typeof options.inputPath !== 'string') {
      errors.push('Missing or invalid inputPath in options')
    }
  }

  // Check results
  if (!('results' in obj) || !Array.isArray(obj.results)) {
    errors.push('Missing or invalid results array')
  } else {
    obj.results.forEach((result, index) => {
      if (typeof result !== 'object' || result === null) {
        errors.push(`Result[${index}] must be an object`)
        return
      }
      const r = result as Record<string, unknown>
      if (!('filePath' in r) || typeof r.filePath !== 'string') {
        errors.push(`Result[${index}] missing filePath`)
      }
      if (!('metadata' in r) || typeof r.metadata !== 'object') {
        errors.push(`Result[${index}] missing metadata`)
      }
      if (!('wordCount' in r) || typeof r.wordCount !== 'number') {
        errors.push(`Result[${index}] missing or invalid wordCount`)
      }
      if (!('tokenCounts' in r) || typeof r.tokenCounts !== 'object') {
        errors.push(`Result[${index}] missing tokenCounts`)
      }
    })
  }

  // Check summary
  if (!('summary' in obj) || typeof obj.summary !== 'object' || obj.summary === null) {
    errors.push('Missing or invalid summary')
  } else {
    const summary = obj.summary as Record<string, unknown>
    if (!('total' in summary) || typeof summary.total !== 'number') {
      errors.push('Summary missing or invalid total')
    }
    if (!('success' in summary) || typeof summary.success !== 'number') {
      errors.push('Summary missing or invalid success')
    }
    if (!('failed' in summary) || typeof summary.failed !== 'number') {
      errors.push('Summary missing or invalid failed')
    }
  }

  return {
    valid: errors.length === 0,
    errors
  }
}
```

Validator should check all required fields from ResultsOutput schema without external dependencies (no ajv).
  </action>
  <verify>web/src/lib/schema-validator.ts exists and exports validateResultsFile and validateResultsOutput functions</verify>
  <done>Schema validator created with comprehensive checks for all ResultsOutput fields</done>
</task>

<task type="auto">
  <name>Task 2: Create FileChip component for compact file display</name>
  <files>web/src/components/file-upload/FileChip.tsx</files>
  <action>
Create FileChip component that shows selected file with remove button:

```typescript
// web/src/components/file-upload/FileChip.tsx
import { FileText, X } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"

interface FileChipProps {
  fileName: string
  onRemove: () => void
}

export function FileChip({ fileName, onRemove }: FileChipProps) {
  return (
    <Badge variant="secondary" className="gap-2 px-3 py-2 text-sm">
      <FileText className="h-4 w-4" />
      <span className="max-w-[200px] truncate">{fileName}</span>
      <Button
        variant="ghost"
        size="sm"
        className="h-auto p-0 hover:bg-transparent"
        onClick={onRemove}
      >
        <X className="h-3 w-3" />
      </Button>
    </Badge>
  )
}
```

Component should show file icon, truncated filename, and X button for removal.
  </action>
  <verify>web/src/components/file-upload/FileChip.tsx exists and exports FileChip component</verify>
  <done>FileChip component created with icon, filename, and remove button</done>
</task>

<task type="auto">
  <name>Task 3: Create FileDropzone with drag states and validation</name>
  <files>web/src/components/file-upload/FileDropzone.tsx</files>
  <action>
Create FileDropzone component with HTML5 drag-and-drop API:

```typescript
// web/src/components/file-upload/FileDropzone.tsx
import { useCallback, useState } from 'react'
import { Upload } from 'lucide-react'
import { cn } from '@/lib/utils'
import { FileChip } from './FileChip'
import { validateResultsFile } from '@/lib/schema-validator'
import { toast } from 'sonner'
import type { ResultsOutput } from '@epub-counter/shared'

interface FileDropzoneProps {
  onFileLoaded: (data: ResultsOutput, fileName: string) => void
}

export function FileDropzone({ onFileLoaded }: FileDropzoneProps) {
  const [isDragging, setIsDragging] = useState(false)
  const [selectedFile, setSelectedFile] = useState<{ name: string; data: ResultsOutput } | null>(null)

  const processFile = useCallback(async (file: File) => {
    try {
      const text = await file.text()
      const json = JSON.parse(text)

      const validation = validateResultsFile(json)
      if (!validation.valid) {
        toast.error('Invalid results.json', {
          description: validation.errors.join(', ')
        })
        return
      }

      setSelectedFile({ name: file.name, data: json })
      onFileLoaded(json, file.name)
      toast.success('Results loaded successfully', {
        description: `Loaded ${json.results.length} EPUB${json.results.length !== 1 ? 's' : ''}`
      })
    } catch (error) {
      toast.error('Failed to parse file', {
        description: error instanceof Error ? error.message : 'Unknown error'
      })
    }
  }, [onFileLoaded])

  const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setIsDragging(false)

    const file = e.dataTransfer.files[0]
    if (file) {
      processFile(file)
    }
  }, [processFile])

  const handleDragOver = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setIsDragging(true)
  }, [])

  const handleDragLeave = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    setIsDragging(false)
  }, [])

  const handleFileSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      processFile(file)
    }
  }, [processFile])

  const handleRemove = useCallback(() => {
    setSelectedFile(null)
  }, [])

  if (selectedFile) {
    return <FileChip fileName={selectedFile.name} onRemove={handleRemove} />
  }

  return (
    <div
      onDrop={handleDrop}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      className={cn(
        "border-2 border-dashed rounded-lg p-8 text-center transition-all cursor-pointer",
        "hover:border-primary/50 hover:bg-primary/5",
        isDragging && "border-primary bg-primary/10 scale-[1.02]",
        !isDragging && "border-muted-foreground/25"
      )}
    >
      <input
        type="file"
        accept=".json"
        onChange={handleFileSelect}
        className="hidden"
        id="file-upload"
      />
      <label htmlFor="file-upload" className="cursor-pointer">
        <Upload className="mx-auto h-12 w-12 text-muted-foreground mb-4" />
        <p className="text-sm font-medium text-foreground">
          Drop results.json file here or click to browse
        </p>
        <p className="text-xs text-muted-foreground mt-2">
          File will be validated against schema v1.0
        </p>
      </label>
    </div>
  )
}
```

Component should:
- Use HTML5 drag-and-drop events (onDrop, onDragOver, onDragLeave)
- Show scale animation when dragging (scale-[1.02])
- Validate JSON with schema validator
- Show Sonner toasts for success/errors
- Switch to FileChip after successful file load
- Support both drag-drop and click-to-browse
  </action>
  <verify>web/src/components/file-upload/FileDropzone.tsx exists and exports FileDropzone component</verify>
  <done>FileDropzone created with drag states, validation, toast notifications, and file picker</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete file upload interface with drag-drop zone, file picker, schema validation, toast notifications, and compact file chip display</what-built>
  <how-to-verify>
1. Start dev server: `npm run dev` from project root
2. Open http://localhost:5173 in browser
3. Create a test component in App.tsx to render FileDropzone:
```tsx
import { FileDropzone } from "./components/file-upload/FileDropzone"
import type { ResultsOutput } from '@epub-counter/shared'

function App() {
  const handleFileLoaded = (data: ResultsOutput, fileName: string) => {
    console.log('File loaded:', fileName, data)
  }

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="max-w-xl mx-auto">
        <h1 className="text-2xl font-bold mb-6">File Upload Test</h1>
        <FileDropzone onFileLoaded={handleFileLoaded} />
      </div>
    </div>
  )
}
```
4. Test drag-drop functionality:
   - Drag a file over the drop zone and verify it expands (scale animation)
   - Drag away and verify it returns to normal
   - Drop a valid results.json file and verify FileChip appears
   - Drop an invalid JSON file and verify error toast appears
   - Drop a JSON with wrong schema and verify validation error toast

5. Test file picker:
   - Click drop zone and verify file picker opens
   - Select a valid results.json file
   - Verify FileChip appears with filename

6. Test FileChip:
   - Verify chip shows file icon and truncated filename
   - Click X button and verify chip disappears, drop zone returns

7. Check console for loaded data output
8. Verify all toasts appear and auto-dismiss
  </how-to-verify>
  <resume-signal>Type "approved" if all features work, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:
1. Schema validator checks all required fields (schemaVersion, timestamp, options, results, summary)
2. FileDropzone provides drag-drop with visual feedback (scale animation)
3. FileDropzone supports click-to-browse via file input
4. Validation errors shown as Sonner toasts with descriptions
5. Success toast shows number of EPUBs loaded
6. FileChip shows after successful file load
7. FileChip remove button clears file and shows drop zone again
8. Component properly handles both valid and invalid files
</verification>

<success_criteria>
Phase 6 Plan 2 is complete when:
1. User can drag file over drop zone and see visual feedback (scale animation)
2. User can drop valid results.json and see FileChip appear
3. User can drop invalid JSON and see error toast
4. User can click drop zone to open file picker
5. User sees validation errors as toasts that auto-dismiss
6. FileChip displays filename with remove button
7. Clicking X removes file and shows drop zone again
8. Component loads ResultsOutput data and passes to parent
</success_criteria>

<output>
After completion, create `.planning/phases/06-file-upload-tokenizer-selection/06-02-SUMMARY.md`
</output>
