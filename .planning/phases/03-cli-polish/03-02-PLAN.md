---
phase: 03-cli-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/errors/logger.ts
  - src/errors/handler.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees errors in console during processing"
    - "User sees error severity level (FATAL/ERROR/WARN)"
    - "Error details written to errors.log file"
    - "errors.log contains timestamp, severity, filename, error message, and suggestion"
  artifacts:
    - path: "src/errors/logger.ts"
      provides: "Severity-based error logging with dual console/file output"
      min_lines: 60
      exports: ["ErrorSeverity", "logError"]
    - path: "src/errors/handler.ts"
      provides: "Error handler using new logger module"
      contains: "import.*from.*logger"
    - path: "errors.log"
      provides: "Persistent error log with severity levels"
      contains: "\\[(FATAL|ERROR|WARN)\\]"
  key_links:
    - from: "src/errors/handler.ts"
      to: "src/errors/logger.ts"
      via: "import { ErrorSeverity, logError }"
      pattern: "import.*logger"
    - from: "src/errors/logger.ts"
      to: "errors.log"
      via: "fs.appendFile"
      pattern: "appendFile.*errors?\\.log"
    - from: "src/errors/logger.ts"
      to: "process.stderr/stdout"
      via: "console.error/warn"
      pattern: "console\\.(error|warn)"
---

<objective>
Implement severity-based error logging system with dual output (console + errors.log file).

Purpose: Professional error handling requires clear severity levels (FATAL stops processing, ERROR continues with visible feedback, WARN is informational) and persistent logging for debugging.

Output: Working error logging system with FATAL/ERROR/WARN levels, console output with moderate intrusiveness, and persistent errors.log file.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-polish/03-RESEARCH.md
@.planning/phases/03-cli-polish/03-CONTEXT.md

# Codebase context
@src/errors/handler.ts
@src/cli/index.ts
</context>

<tasks>

<task type="auto">
  <name>Create error logger module with severity levels</name>
  <files>src/errors/logger.ts</files>
  <action>
    Create src/errors/logger.ts with severity-based error logging:

    **Requirements from RESEARCH.md:**
    - Severity enum: FATAL (catastrophic), ERROR (file skipped), WARN (partial results)
    - Dual output: Console (moderately intrusive) + errors.log file (persistent)
    - Console behavior: FATAL exits with error, ERROR pauses 500ms then continues, WARN is informational
    - Log format: "[timestamp] [SEVERITY] file: error Suggestion: suggestion" (if applicable)

    **Code structure:**
    ```typescript
    import fs from 'fs/promises';
    import path from 'path';

    export enum ErrorSeverity {
      FATAL = 'FATAL',   // Catastrophic, cannot continue
      ERROR = 'ERROR',   // File skipped but processing continues
      WARN = 'WARN'      // Partial results, processing succeeds
    }

    export interface ErrorLogEntry {
      timestamp: string;      // ISO 8601
      severity: ErrorSeverity;
      file: string;
      error: string;
      suggestion?: string;
    }

    export async function logError(entry: ErrorLogEntry, outputDir: string = './results'): Promise<void> {
      const consoleMsg = `[${entry.severity}] ${entry.file}: ${entry.error}`;

      // Console output based on severity
      if (entry.severity === ErrorSeverity.FATAL) {
        console.error(consoleMsg);
        if (entry.suggestion) console.error(`  Suggestion: ${entry.suggestion}`);
      } else if (entry.severity === ErrorSeverity.ERROR) {
        console.error(consoleMsg);
        // Brief pause for visibility
        await new Promise(resolve => setTimeout(resolve, 500));
      } else {
        console.warn(consoleMsg);
      }

      // File output (persistent)
      try {
        await fs.mkdir(outputDir, { recursive: true });
        const logPath = path.join(outputDir, 'errors.log');
        const logLine = `[${entry.timestamp}] [${entry.severity}] ${entry.file}: ${entry.error}${entry.suggestion ? ` Suggestion: ${entry.suggestion}` : ''}\n`;
        await fs.appendFile(logPath, logLine);
      } catch (error) {
        // Fallback to console if file logging fails
        console.error(`Failed to write to errors.log: ${error}`);
      }
    }
    ```

    **Key differences from existing logError in handler.ts:**
    - New: Severity enum (FATAL/ERROR/WARN)
    - New: Console behavior varies by severity (pause for ERROR, no pause for WARN)
    - New: ISO 8601 timestamp in log file
    - Keep: Suggestion generation (moved from handler.ts)
    - Keep: Fallback to console on file write failure
  </action>
  <verify>Check that:
  - src/errors/logger.ts exists
  - Exports ErrorSeverity enum (FATAL, ERROR, WARN)
  - Exports logError function with ErrorLogEntry parameter
  - Console output varies by severity (FATAL=exit, ERROR=pause, WARN=no pause)
  - File output includes timestamp, severity, file, error, suggestion
  - Has try/catch for file write failures
  </verify>
  <done>Logger module with severity levels created</done>
</task>

<task type="auto">
  <name>Refactor handler.ts to use new logger module</name>
  <files>src/errors/handler.ts</files>
  <action>
    Modify src/errors/handler.ts to use new logger module instead of inline logging:

    **Changes:**

    1. Add import:
    ```typescript
    import { ErrorSeverity, logError } from './logger.js';
    ```

    2. Remove existing ErrorLogEntry interface and logError function (lines 31-94) - replaced by logger.ts

    3. Update generateSuggestion to map to severity levels:
    ```typescript
    function classifyError(error: Error, filePath: string): { severity: ErrorSeverity; suggestion?: string } {
      const errorCode = (error as any).code;
      const message = error.message.toLowerCase();

      // File not found - usually FATAL if input path is wrong
      if (errorCode === 'ENOENT') {
        return { severity: ErrorSeverity.ERROR, suggestion: 'File not found. Check the file path.' };
      }

      // Permission denied - ERROR (can't process this file)
      if (errorCode === 'EACCES') {
        return { severity: ErrorSeverity.ERROR, suggestion: 'Check file permissions.' };
      }

      // EPUB parsing errors - ERROR (file skipped)
      if (message.includes('epub') || message.includes('parse') || message.includes('zip')) {
        return { severity: ErrorSeverity.ERROR, suggestion: 'File may be corrupted or not a valid EPUB.' };
      }

      // Memory limit errors - FATAL (user must adjust)
      if (message.includes('exceeds --max-mb limit')) {
        return { severity: ErrorSeverity.FATAL, suggestion: 'Increase --max-mb or process in smaller chunks.' };
      }

      // Default: ERROR (unknown issue, skip file)
      return { severity: ErrorSeverity.ERROR };
    }
    ```

    4. Update error handling in processEpubsWithErrors loop (lines 213-242):
    ```typescript
    } catch (error) {
      const errorObj = error as Error;
      const errorMessage = errorObj.message || 'Unknown error';
      const { severity, suggestion } = classifyError(errorObj, filePath);

      // Create error log entry with severity
      const entry: ErrorLogEntry = {
        timestamp: new Date().toISOString(),
        severity,
        file: filePath,
        error: errorMessage,
        suggestion,
      };

      // Log using new logger module
      await logError(entry, outputDir);

      // Add to failed array
      failed.push({
        file: filePath,
        error: errorMessage,
        suggestion,
      });

      // FATAL errors stop processing
      if (severity === ErrorSeverity.FATAL) {
        throw errorObj; // Re-throw to stop processing
      }
    }
    ```

    **Important:** Keep existing successful/failed array structure and tokenCounts logic. Only change how errors are logged.
  </action>
  <verify>Check that:
  - Imports ErrorSeverity and logError from logger.ts
  - Removes old logError function and ErrorLogEntry interface
  - Has classifyError function returning severity + suggestion
  - Uses logError() from logger module
  - FATAL errors re-throw to stop processing
  - ERROR/WARN errors continue processing
  </verify>
  <done>Error handler uses new severity-based logger</done>
</task>

<task type="auto">
  <name>Update CLI to handle FATAL errors properly</name>
  <files>src/cli/index.ts</files>
  <action>
    Modify src/cli/index.ts to handle FATAL errors properly (exit immediately, don't show summary):

    **Changes:**

    1. Wrap processEpubs call in try/catch to catch FATAL errors:
    ```typescript
    processEpubs(inputPaths, { ...options, tokenizers, maxMb })
      .catch((error) => {
        // FATAL errors already logged by logger module
        // Just exit with error code
        process.exit(1);
      });
    ```

    2. Update processEpubs function to check for FATAL errors and skip summary:
    ```typescript
    async function processEpubs(inputPaths: string[], options: any): Promise<void> {
      // ... existing code ...

      try {
        const result = await processEpubsWithErrors(
          allFiles,
          options.verbose,
          outputDir,
          tokenizers,
          maxMb
        );
      } catch (error) {
        // FATAL error - exit without summary
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`\nFatal error: ${errorMessage}`);
        console.error('Processing stopped.');
        process.exit(1);
      }

      // ... rest of function (displayResults, write files, summary) ...
    }
    ```

    **Behavior:**
    - FATAL errors: Stop processing immediately, exit with code 1, no summary
    - ERROR errors: Continue processing, show summary with failed count
    - WARN errors: Continue processing, show summary
  </action>
  <verify>Check that:
  - processEpubs catches FATAL errors from processEpubsWithErrors
  - FATAL errors exit immediately without showing summary
  - ERROR/WARN errors continue to summary display
  - Exit code 1 for FATAL, exit code 0 for partial success (some files failed)
  </verify>
  <done>FATAL errors stop processing immediately</done>
</task>

</tasks>

<verification>
1. Create test EPUB files in various states (valid, corrupted, missing)
2. Run epub-counter and verify error logging
3. Check errors.log file format and content
4. Verify severity levels affect console output behavior

Test commands:
```bash
# Test ERROR severity (corrupted EPUB)
cp invalid.epub ./epubs/
epub-counter ./epubs/

# Test FATAL severity (memory limit exceeded)
epub-counter ./epubs/ --max-mb 0.001

# Verify errors.log format
cat ./results/errors.log
```

Expected output:
- Console shows "[ERROR] file.epub: error message" with 500ms pause
- errors.log has "[2026-01-21T...] [ERROR] file.epub: error Suggestion: fix"
- FATAL errors stop processing immediately
- ERROR errors continue processing
</verification>

<success_criteria>
- Error severity levels (FATAL/ERROR/WARN) displayed in console
- errors.log file created with timestamp, severity, file, error, suggestion
- FATAL errors stop processing immediately
- ERROR errors continue with visible pause
- WARN errors continue without pause
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-polish/03-02-SUMMARY.md`
</output>
