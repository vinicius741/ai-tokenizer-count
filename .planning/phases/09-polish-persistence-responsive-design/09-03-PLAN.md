---
phase: 09-polish-persistence-responsive-design
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/ui/skeleton.tsx
  - web/src/components/ui/spinner.tsx
  - web/src/components/visualization/ResultsTable.tsx
  - web/src/components/processing/ProcessButton.tsx
  - web/src/components/budget/BudgetCalculator.tsx
autonomous: true

must_haves:
  truths:
    - "UI shows skeleton screens during data fetch"
    - "UI shows loading spinners on buttons during async operations"
  artifacts:
    - path: "web/src/components/ui/skeleton.tsx"
      provides: "shadcn/ui Skeleton component for loading placeholders"
      exports: ["Skeleton"]
    - path: "web/src/components/ui/spinner.tsx"
      provides: "shadcn/ui Spinner component for loading indicators"
      exports: ["Spinner"]
    - path: "web/src/components/visualization/ResultsTable.tsx"
      provides: "Results table with skeleton loading state"
      contains: "isLoading.*Skeleton"
    - path: "web/src/components/processing/ProcessButton.tsx"
      provides: "Process button with spinner during async operation"
      contains: "Spinner.*isProcessing"
  key_links:
    - from: "web/src/components/processing/ProcessButton.tsx"
      to: "web/src/components/ui/spinner.tsx"
      via: "Import Spinner component for button loading state"
      pattern: "import.*Spinner.*from.*@/components/ui/spinner"
    - from: "web/src/components/visualization/ResultsTable.tsx"
      to: "web/src/components/ui/skeleton.tsx"
      via: "Import Skeleton component for loading placeholder"
      pattern: "import.*Skeleton.*from.*@/components/ui/skeleton"
---

<objective>
Add shadcn/ui Skeleton and Spinner components, implement skeleton loading states for data fetch, and add loading spinners to buttons during async operations.

Purpose: Users have no visual feedback during data loading and async operations, causing confusion about whether the app is working. Skeleton screens reduce perceived wait time and spinners indicate active operations.

Output: Installed shadcn/ui Skeleton and Spinner components, skeleton states for ResultsTable, loading spinners on ProcessButton and other async buttons.
</objective>

<execution_context>
@/Users/vinicusmoreira/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vinicusmoreira/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-polish-persistence-responsive-design/09-RESEARCH.md
@web/package.json
@web/src/components/visualization/ResultsTable.tsx
@web/src/components/processing/ProcessButton.tsx

# Only reference prior plan SUMMARYs if genuinely needed
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn/ui Skeleton and Spinner components</name>
  <files>web/src/components/ui/skeleton.tsx, web/src/components/ui/spinner.tsx</files>
  <action>
Run shadcn CLI to add Skeleton and Spinner components:

```bash
cd web
npx shadcn@latest add skeleton
npx shadcn@latest add spinner
```

If spinner component is not available in shadcn (it's newer), check if it was added and verify the files exist:
- `web/src/components/ui/skeleton.tsx`
- `web/src/components/ui/spinner.tsx`

If spinner doesn't exist, create a simple Spinner component:
```typescript
import { cn } from '@/lib/utils'
import { Loader2 } from 'lucide-react'

export interface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {
  size?: 'default' | 'sm' | 'lg'
}

export function Spinner({ className, size = 'default', ...props }: SpinnerProps) {
  const sizeClasses = {
    default: 'h-4 w-4',
    sm: 'h-3 w-3',
    lg: 'h-6 w-6'
  }

  return (
    <Loader2 className={cn('animate-spin', sizeClasses[size], className)} {...props} />
  )
}
```

DO NOT hand-roll custom CSS spinners - use lucide-react Loader2 with animate-spin.
  </action>
  <verify>
Files exist at `web/src/components/ui/skeleton.tsx` and `web/src/components/ui/spinner.tsx`. TypeScript compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
shadcn/ui Skeleton and Spinner components are installed and available for use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add skeleton loading state to ResultsTable</name>
  <files>web/src/components/visualization/ResultsTable.tsx</files>
  <action>
Modify `web/src/components/visualization/ResultsTable.tsx` to:

1. Read existing ResultsTable component structure
2. Add optional `isLoading` prop to interface
3. Create ResultsTableSkeleton component (can be in same file or separate):
   - Match exact structure of ResultsTable (Card wrapper, header)
   - Use Skeleton components for:
     - Header: `Skeleton className="h-6 w-48"`
     - Table rows: Map over [0,1,2,3,4] creating skeleton rows
     - Each row: Skeleton for filename cell, skeleton for count cells
   - Match dimensions to actual table rows (height, spacing)
4. In main ResultsTable, add conditional render:
   ```tsx
   if (isLoading) {
     return <ResultsTableSkeleton />
   }
   ```

Pattern: Use the skeleton pattern from RESEARCH.md (lines 290-329).
Ensure skeleton dimensions match actual content to prevent layout shift.
  </action>
  <verify>
ResultsTable.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
ResultsTable displays skeleton placeholder during data loading, matching the actual table structure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add loading spinner to ProcessButton</name>
  <files>web/src/components/processing/ProcessButton.tsx</files>
  <action>
Read and modify `web/src/components/processing/ProcessButton.tsx` to:

1. Import Spinner from `@/components/ui/spinner`
2. Read existing button structure (likely already has isProcessing prop)
3. Add Spinner inside button when isProcessing is true:
   ```tsx
   <Button disabled={isProcessing} className="min-h-[44px]">
     {isProcessing && <Spinner className="mr-2" />}
     {isProcessing ? 'Processing...' : 'Process EPUBs'}
   </Button>
   ```
4. Ensure Spinner has `className="mr-2"` for spacing from text
5. Keep disabled state to prevent double-clicks

Pattern: Use the button loading pattern from RESEARCH.md (lines 333-358).
  </action>
  <verify>
ProcessButton.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
ProcessButton shows spinner and disabled state during processing.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add loading states to BudgetCalculator components</name>
  <files>web/src/components/budget/BudgetCalculator.tsx, web/src/components/budget/BudgetSummary.tsx</files>
  <action>
Read and modify budget calculator components to add loading states:

1. Read `web/src/components/budget/BudgetCalculator.tsx`
2. Check if there's any async computation (knapsack solver might be slow)
3. If useBudgetCalculator hook has isLoading state, pass it through
4. Add Skeleton to BudgetSummary if calculations are in progress:
   - Skeleton for budget progress bar
   - Skeleton for selected books list
5. Add loading state to any export buttons if they have async operations:
   - Copy to clipboard button
   - Download JSON button

Pattern: Apply same skeleton pattern as ResultsTable - match actual component structure.
If no async operations exist in budget calculator, this task can be minimal (just verify no loading states needed).
  </action>
  <verify>
BudgetCalculator.tsx and BudgetSummary.tsx compile: `cd web && npx tsc --noEmit`
  </verify>
  <done>
Budget calculator components show loading states during async operations if present.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add skeleton state to chart components</name>
  <files>web/src/components/visualization/BarChart.tsx, web/src/components/visualization/ScatterChart.tsx</files>
  <action>
Read and modify chart components for loading states:

1. Read `web/src/components/visualization/BarChart.tsx`
2. Add optional `isLoading` prop
3. Create ChartSkeleton component matching chart dimensions:
   - Card wrapper with same height as chart
   - Skeleton for title area
   - Large Skeleton rectangle for chart area
4. Add conditional render: show skeleton when isLoading=true
5. Repeat for `ScatterChart.tsx` if needed

Alternatively, if charts render quickly from local data, skeleton may not be needed - use judgment.
Charts that fetch data via API definitely need skeletons. Charts rendering from passed props may not.

Pattern: Match skeleton height to chart height/aspect to prevent layout shift.
  </action>
  <verify>
BarChart.tsx and ScatterChart.tsx compile: `cd web && npx tsc --noEmit`
  </verify>
  <done>
Chart components show skeleton placeholders during data loading.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Start dev server: `cd web && npm run dev`
2. Upload results.json or process EPUBs
3. Verify ResultsTable shows skeleton before data loads
4. Click Process button and verify spinner appears
5. Check budget calculator for loading states (if applicable)
6. Verify no layout shift when skeleton transitions to actual content
7. Test on slow connection (Chrome DevTools > Network > Throttling > Slow 3G)
</verification>

<success_criteria>
Loading states are working when:
- [ ] Skeleton components are installed and available
- [ ] Spinner components are installed and available
- [ ] ResultsTable shows skeleton matching table structure before data loads
- [ ] ProcessButton shows spinner and changes text to "Processing..." when active
- [ ] All skeleton screens match actual content dimensions (no layout shift)
- [ ] Loading states are visible even on fast connections (brief flash)
- [ ] All async buttons have loading indicators
</success_criteria>

<output>
After completion, create `.planning/phases/09-polish-persistence-responsive-design/09-03-SUMMARY.md`
</output>
