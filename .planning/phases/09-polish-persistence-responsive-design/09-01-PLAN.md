---
phase: 09-polish-persistence-responsive-design
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/hooks/use-local-storage.ts
  - web/src/components/persistence/RestoreDialog.tsx
  - web/src/components/persistence/NewSessionButton.tsx
  - web/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "UI shows prompt to restore saved results on page load if previous session exists"
    - "User can click 'New Session' button to clear all saved data"
    - "Processing results are auto-saved to localStorage on completion"
    - "User sees warning toast if localStorage 5MB limit is exceeded"
  artifacts:
    - path: "web/src/hooks/use-local-storage.ts"
      provides: "Enhanced hook with quota detection and clearValue return"
      exports: ["useLocalStorage"]
      min_lines: 35
    - path: "web/src/components/persistence/RestoreDialog.tsx"
      provides: "Dialog component for session restoration prompt"
      min_lines: 40
    - path: "web/src/components/persistence/NewSessionButton.tsx"
      provides: "Button component to clear all saved data"
      min_lines: 30
    - path: "web/src/lib/storage-utils.ts"
      provides: "Utility functions for safe localStorage operations"
      exports: ["saveToLocalStorage", "loadFromLocalStorage", "clearLocalStorageKey"]
      min_lines: 50
  key_links:
    - from: "web/src/App.tsx"
      to: "web/src/hooks/use-local-storage.ts"
      via: "useState hook for processingResults persistence"
      pattern: "useLocalStorage.*epub-counter-results"
    - from: "web/src/App.tsx"
      to: "web/src/components/persistence/RestoreDialog.tsx"
      via: "Conditional render based on saved data existence"
      pattern: "hasSavedData.*RestoreDialog"
---

<objective>
Implement session persistence using localStorage with automatic save on completion, restoration prompt on page load, and ability to clear saved data.

Purpose: Users lose their processing results when refreshing the page, causing frustration and requiring reprocessing. Auto-saving results to localStorage ensures data persists across sessions.

Output: Enhanced useLocalStorage hook with quota handling, RestoreDialog component, NewSessionButton component, and integrated persistence in App.tsx.
</objective>

<execution_context>
@/Users/vinicusmoreira/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vinicusmoreira/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-polish-persistence-responsive-design/09-RESEARCH.md
@web/src/hooks/use-local-storage.ts
@web/src/App.tsx

# Only reference prior plan SUMMARYs if genuinely needed
@web/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage utility functions with quota detection</name>
  <files>web/src/lib/storage-utils.ts</files>
  <action>
Create new file `web/src/lib/storage-utils.ts` with:

1. `saveToLocalStorage<T>(key, value, options)` function that:
   - Stringifies value to JSON
   - Calculates size using `new Blob([serialized]).size`
   - Throws error if size exceeds quotaMB (default 5)
   - Wraps localStorage.setItem in try-catch
   - Returns boolean success
   - Calls onError callback if QuotaExceededError occurs

2. `loadFromLocalStorage<T>(key)` function that:
   - Wraps localStorage.getItem in try-catch
   - Returns null on error (logs to console)
   - Parses JSON or returns null if item doesn't exist

3. `clearLocalStorageKey(key)` function that:
   - Wraps localStorage.removeItem in try-catch
   - Logs error if clearing fails

Pattern: Use the QuotaExceededError handling pattern from RESEARCH.md (lines 399-417).
Do NOT hand-roll custom JSON parsing - use native JSON.parse/stringify.
  </action>
  <verify>
File exists at `web/src/lib/storage-utils.ts` with exports saveToLocalStorage, loadFromLocalStorage, clearLocalStorageKey. TypeScript compiles without errors: `cd web && npx tsc --noEmit`
  </verify>
  <done>
storage-utils.ts provides three utility functions that handle localStorage operations with quota detection and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance useLocalStorage hook with quota handling</name>
  <files>web/src/hooks/use-local-storage.ts</files>
  <action>
Modify existing `web/src/hooks/use-local-storage.ts` to:

1. Import from storage-utils: `saveToLocalStorage`, `loadFromLocalStorage`, `clearLocalStorageKey`
2. Import toast from 'sonner'
3. Add third return value `clearValue` callback
4. Update `setValue` implementation to:
   - Use `saveToLocalStorage` with quotaMB: 5
   - Add onError callback that shows toast.error with 30000ms duration
   - Only update state if save succeeds
5. Add `clearValue` function that:
   - Calls `clearLocalStorageKey(key)`
   - Resets state to initialValue
6. Return tuple: `[storedValue, setValue, clearValue] as const`

Reference: Existing hook pattern at web/src/hooks/use-local-storage.ts
DO NOT change the hook's API signature - only add the third return value.
  </action>
  <verify>
Hook exports three values: storedValue, setValue, clearValue. TypeScript compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
useLocalStorage hook now handles QuotaExceededError with user feedback and provides clearValue function for resetting state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RestoreDialog component</name>
  <files>web/src/components/persistence/RestoreDialog.tsx</files>
  <action>
Create new file `web/src/components/persistence/RestoreDialog.tsx` with:

1. Props interface: `{ hasSavedData: boolean, onRestore: () => void, onClear: () => void }`
2. Local state: `const [open, setOpen] = useState(false)`
3. useEffect that opens dialog when hasSavedData is true
4. Dialog from @/components/ui/dialog with:
   - DialogTitle: "Restore Previous Session?"
   - DialogDescription: "We found saved results from your last session. Would you like to restore them or start fresh?"
   - DialogFooter with two buttons:
     - "Start Fresh" (variant="outline") calls onClear
     - "Restore Results" calls onRestore and closes dialog

Pattern: Use the restoration dialog pattern from RESEARCH.md (lines 140-180).
Do NOT create custom dialog - use shadcn/ui Dialog component already installed.
  </action>
  <verify>
Component exists and compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
RestoreDialog component prompts users to restore saved session when previous data exists in localStorage.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create NewSessionButton component</name>
  <files>web/src/components/persistence/NewSessionButton.tsx</files>
  <action>
Create new file `web/src/components/persistence/NewSessionButton.tsx` with:

1. Props interface: `{ onClear: () => void }`
2. Button from @/components/ui/button with:
   - variant="outline"
   - className="w-full min-h-[44px]" (touch target requirement)
   - Icon: RotateCcw from lucide-react
   - Label: "New Session"
   - onClick calls onClear

Include optional confirmation dialog before clearing if you want extra safety, but not required.
Ensure min-h-[44px] for mobile touch targets (RESP-04 requirement).
  </action>
  <verify>
Component exists and compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
NewSessionButton component allows users to clear all saved data and start fresh.
  </done>
</task>

<task type="auto">
  <name>Task 5: Integrate persistence into App.tsx</name>
  <files>web/src/App.tsx</files>
  <action>
Modify `web/src/App.tsx` to:

1. Import useLocalStorage, RestoreDialog, NewSessionButton
2. Replace `useState<ResultsOutput | null>(null)` with useLocalStorage hook:
   ```typescript
   const [processingResults, setProcessingResults, clearResults] = useLocalStorage<ResultsOutput | null>(
     'epub-counter-results',
     null
   )
   ```
3. Add handler functions:
   - `handleRestoreSession()`: Sets processingResults from localStorage (already loaded by hook)
   - `handleNewSession()`: Calls clearResults(), resets all other state
4. Add RestoreDialog in JSX before main Card:
   ```tsx
   <RestoreDialog
     hasSavedData={!!processingResults && !currentJobId}
     onRestore={handleRestoreSession}
     onClear={handleNewSession}
   />
   ```
5. Add NewSessionButton in header section (after CardTitle)
6. Ensure handleReset also calls clearResults() when user manually resets

CRITICAL: Only show RestoreDialog when there's saved data AND no active job. Don't show dialog during active processing.
  </action>
  <verify>
App.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
App.tsx now persists processing results to localStorage, shows restoration prompt on page load, and provides New Session button to clear data.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Start dev server: `cd web && npm run dev`
2. Process some EPUBs to generate results
3. Refresh browser page - should see "Restore Previous Session?" dialog
4. Click "Restore Results" - previous results should appear
5. Refresh again, click "Start Fresh" - results should be cleared
6. Process results again, verify they appear after refresh automatically
7. Check console for QuotaExceededError handling (try with large dataset if available)
</verification>

<success_criteria>
Session persistence is working when:
- [ ] Results are saved to localStorage when processing completes
- [ ] Restoration dialog appears on page load when saved data exists
- [ ] "Restore Results" button loads previous session
- [ ] "Start Fresh" button clears all saved data
- [ ] New Session button in header clears localStorage
- [ ] QuotaExceededError shows warning toast instead of crashing UI
- [ ] All states persist correctly across page refreshes
</success_criteria>

<output>
After completion, create `.planning/phases/09-polish-persistence-responsive-design/09-01-SUMMARY.md`
</output>
