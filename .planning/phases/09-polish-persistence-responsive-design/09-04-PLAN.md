---
phase: 09-polish-persistence-responsive-design
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/components/error-boundary/ErrorBoundary.tsx
  - web/src/main.tsx
  - web/src/hooks/use-sse-connection.ts
  - web/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Error boundaries catch component rendering errors"
    - "Error boundaries display friendly error message with retry button"
    - "Error boundaries log error stack to console (no telemetry)"
    - "UI shows error toast after 30s timeout without response"
  artifacts:
    - path: "web/src/components/error-boundary/ErrorBoundary.tsx"
      provides: "React class component error boundary with fallback UI"
      exports: ["ErrorBoundary"]
      min_lines: 50
    - path: "web/src/main.tsx"
      provides: "App entry point wrapped in ErrorBoundary"
      contains: "ErrorBoundary"
    - path: "web/src/hooks/use-sse-connection.ts"
      provides: "SSE hook with 30-second timeout error toast"
      contains: "setTimeout.*30000"
  key_links:
    - from: "web/src/main.tsx"
      to: "web/src/components/error-boundary/ErrorBoundary.tsx"
      via: "Wrapping App component in ErrorBoundary"
      pattern: "<ErrorBoundary>.*<App"
    - from: "web/src/hooks/use-sse-connection.ts"
      to: "sonner toast"
      via: "30-second timeout with error toast"
      pattern: "toast\.error.*30000"
---

<objective>
Implement error boundaries to catch component rendering errors, add 30-second timeout error handling for SSE connections, and ensure friendly error messages with retry functionality.

Purpose: Component errors cause white screen crashes with no user feedback. Long-running operations hang indefinitely without timeout indication. Users need clear error messages and recovery options.

Output: ErrorBoundary component wrapping the app, SSE timeout handling with error toasts, and console error logging without telemetry.
</objective>

<execution_context>
@/Users/vinicusmoreira/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vinicusmoreira/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/09-polish-persistence-responsive-design/09-RESEARCH.md
@web/src/main.tsx
@web/src/hooks/use-sse-connection.ts
@web/src/App.tsx

# Only reference prior plan SUMMARYs if genuinely needed
@web/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component</name>
  <files>web/src/components/error-boundary/ErrorBoundary.tsx</files>
  <action>
Create new file `web/src/components/error-boundary/ErrorBoundary.tsx`:

1. Use React class component pattern (Error boundaries MUST be class components):
```typescript
import React, { Component, ErrorInfo, ReactNode } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error stack to console (UX-06) - no telemetry
    console.error('ErrorBoundary caught an error:', error, errorInfo)
    console.error('Component stack:', errorInfo.componentStack)
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null })
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="flex items-center justify-center min-h-screen p-4">
          <Card className="border-destructive max-w-md w-full">
            <CardHeader>
              <CardTitle className="text-destructive">Something went wrong</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <p className="text-sm text-muted-foreground">
                An unexpected error occurred. Please try again or contact support if the problem persists.
              </p>
              {this.state.error && (
                <details className="text-xs text-muted-foreground">
                  <summary className="cursor-pointer">Error details</summary>
                  <pre className="mt-2 p-2 bg-muted rounded overflow-auto">
                    {this.state.error.toString()}
                  </pre>
                </details>
              )}
              <Button onClick={this.handleRetry} variant="outline" className="w-full min-h-[44px]">
                Retry
              </Button>
            </CardContent>
          </Card>
        </div>
      )
    }

    return this.props.children
  }
}
```

2. Add `export { ErrorBoundary }` at end

Pattern: Use the ErrorBoundary pattern from RESEARCH.md (lines 219-287).
DO NOT use try-catch in render - only ErrorBoundary can catch render errors.
  </action>
  <verify>
ErrorBoundary.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
ErrorBoundary component catches rendering errors and displays friendly fallback UI with retry button.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap App in ErrorBoundary in main.tsx</name>
  <files>web/src/main.tsx</files>
  <action>
Read and modify `web/src/main.tsx` to:

1. Import ErrorBoundary: `import { ErrorBoundary } from './components/error-boundary/ErrorBoundary'`
2. Wrap the App component in ErrorBoundary:
```tsx
<ErrorBoundary>
  <App />
</ErrorBoundary>
```
3. Keep existing Toaster from sonner inside ErrorBoundary but outside App

Pattern: ErrorBoundary should be at the top level to catch all rendering errors.
  </action>
  <verify>
main.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
main.tsx wraps App in ErrorBoundary to catch all rendering errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add 30-second timeout to SSE connection hook</name>
  <files>web/src/hooks/use-sse-connection.ts</files>
  <action>
Read and modify `web/src/hooks/use-sse-connection.ts` to:

1. Read existing SSE connection implementation
2. Add timeout logic:
   - When SSE connection opens, start a 30-second timeout
   - Clear timeout when any message is received
   - Restart timeout after each message
   - Show error toast if timeout fires
3. Import toast from 'sonner'
4. Add timeout state and useEffect:
```typescript
const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null)

useEffect(() => {
  if (isConnected) {
    // Clear any existing timeout
    if (timeoutId) clearTimeout(timeoutId)

    // Set new 30-second timeout
    const id = setTimeout(() => {
      toast.error('Connection timeout', {
        description: 'No response received after 30 seconds. Please try again.',
        duration: 30000,
        action: {
          label: 'Retry',
          onClick: () => window.location.reload()
        }
      })
    }, 30000)

    setTimeoutId(id)
  }

  return () => {
    if (timeoutId) clearTimeout(timeoutId)
  }
}, [isConnected, lastMessage]) // Reset timeout on new message
```

5. Ensure cleanup clears timeout

Pattern: Use the timeout toast pattern from RESEARCH.md (lines 664-689).
  </action>
  <verify>
use-sse-connection.ts compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
SSE connection shows error toast after 30 seconds without response, with retry action.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add error handling to ProcessingProgress component</name>
  <files>web/src/components/processing/ProcessingProgress.tsx</files>
  <action>
Read and modify `web/src/components/processing/ProcessingProgress.tsx` to:

1. Read existing component structure
2. Check if SSE hook already exposes error state
3. If error state exists, show error UI:
   - Error message card with border-destructive styling
   - Clear error message explaining what went wrong
   - Retry button that calls retry handler or reloads page
4. Add error toast for SSE failures:
```typescript
useEffect(() => {
  if (error) {
    toast.error('Processing error', {
      description: error.message || 'An error occurred while processing EPUBs',
      duration: 30000,
    })
  }
}, [error])
```

5. Ensure errors don't cause white screen - show in-UI error message instead

Pattern: Errors should be caught and displayed, not allowed to propagate to ErrorBoundary if possible.
  </action>
  <verify>
ProcessingProgress.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
ProcessingProgress displays error messages when SSE connection fails or processing errors occur.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add error handling to FileDropzone component</name>
  <files>web/src/components/file-upload/FileDropzone.tsx</files>
  <action>
Read and modify `web/src/components/file-upload/FileDropzone.tsx` to:

1. Read existing file upload logic
2. Wrap file reading in try-catch
3. Show error toast on file read failures:
```typescript
try {
  const data = await file.text()
  const json = JSON.parse(data)
  // ... validation logic
} catch (error) {
  toast.error('Failed to load file', {
    description: error instanceof Error ? error.message : 'Unable to read the uploaded file',
    duration: 10000,
  })
  return
}
```

4. Ensure schema validation errors also show toast with specific error message

Pattern: All file operations should have try-catch with user-friendly error messages.
  </action>
  <verify>
FileDropzone.tsx compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
FileDropzone shows error toast for file read failures and schema validation errors.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Start dev server: `cd web && npm run dev`
2. Test ErrorBoundary by adding a deliberate error to a component (temporarily):
   - Add `throw new Error('Test error')` in a component's render
   - Verify ErrorBoundary catches it and shows friendly UI
   - Verify error is logged to console (not telemetry)
   - Remove test error
3. Test SSE timeout by stopping backend during processing
4. Verify timeout toast appears after 30 seconds
5. Test file upload errors with invalid files (non-JSON, malformed JSON)
6. Verify error messages are clear and actionable
</verification>

<success_criteria>
Error handling is working when:
- [ ] ErrorBoundary wraps App in main.tsx
- [ ] Deliberate render errors show friendly UI with retry button
- [ ] Errors are logged to console (check browser console)
- [ ] SSE timeout shows error toast after 30 seconds with retry action
- [ ] File upload errors show descriptive error toast
- [ ] No telemetry or external error reporting (only console logs)
- [ ] All error messages are user-friendly (no stack traces in UI unless expanded)
</success_criteria>

<output>
After completion, create `.planning/phases/09-polish-persistence-responsive-design/09-04-SUMMARY.md`
</output>
