---
phase: 08-token-budget-calculator
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/lib/knapsack.ts
  - web/src/lib/pricing-data.ts
  - web/src/hooks/use-budget-calculator.ts
autonomous: true

must_haves:
  truths:
    - "Knapsack algorithm selects EPUBs within budget constraint using greedy optimization"
    - "Max Books strategy selects shortest books first to maximize count"
    - "Max Words strategy selects longest books that fit to maximize total word count"
    - "Balanced strategy selects books by word-to-token ratio for balance"
    - "Algorithm returns empty array when budget is insufficient for any EPUB"
    - "useBudgetCalculator hook memoizes calculation and only recalculates on input changes"
  artifacts:
    - path: "web/src/lib/knapsack.ts"
      provides: "Greedy knapsack algorithms for three optimization strategies"
      min_lines: 80
      exports: ["solveKnapsack", "knapsackMaxBooks", "knapsackMaxWords", "knapsackBalanced"]
    - path: "web/src/lib/pricing-data.ts"
      provides: "Provider pricing constants and cost calculation functions"
      min_lines: 60
      exports: ["PROVIDER_PRICING", "calculateCost", "getAllCostEstimates"]
    - path: "web/src/hooks/use-budget-calculator.ts"
      provides: "Main hook managing budget calculation with knapsack algorithm"
      min_lines: 100
      exports: ["useBudgetCalculator"]
  key_links:
    - from: "web/src/hooks/use-budget-calculator.ts"
      to: "web/src/lib/knapsack.ts"
      via: "Import solveKnapsack for EPUB selection algorithm"
      pattern: "import.*solveKnapsack|solveKnapsack\\("
    - from: "web/src/hooks/use-budget-calculator.ts"
      to: "web/src/lib/pricing-data.ts"
      via: "Import cost calculation functions for estimation"
      pattern: "import.*pricing|getAllCostEstimates"
    - from: "web/src/lib/knapsack.ts"
      to: "@epub-counter/shared"
      via: "Import EpubResult, TokenizerType types"
      pattern: "from '@epub-counter/shared'"
---

<objective>
Implement greedy knapsack algorithms for three optimization strategies and pricing data for cost estimation with memoized calculation hook.

**Purpose:** The core business logic for budget optimization requires efficient selection of EPUBs within a token budget constraint. Three strategies (Max Books, Max Words, Balanced) use greedy algorithms to provide near-optimal results without exponential complexity. Pricing data enables cost estimation display in the UI.

**Output:** Working knapsack solver with:
- Three greedy algorithms (Max Books: shortest-first, Max Words: longest-fit, Balanced: ratio-based)
- solveKnapsack function that filters valid EPUBs, validates budget, executes strategy
- Provider pricing data for OpenAI, Anthropic, Google (as of 2026-01)
- Cost calculation functions that estimate processing costs per provider
- useBudgetCalculator hook that memoizes calculations and manages state
</objective>

<execution_context>
@/Users/vinicusmoreira/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vinicusmoreira/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-token-budget-calculator/08-CONTEXT.md
@.planning/phases/08-token-budget-calculator/08-RESEARCH.md
@packages/shared/src/types.ts
@web/src/hooks/use-local-storage.ts
@web/src/hooks/use-debounce.ts
</context>

<tasks>

<task type="auto">
  <name>Implement knapsack algorithms</name>
  <files>web/src/lib/knapsack.ts</files>
  <action>
    Create web/src/lib/knapsack.ts with greedy knapsack implementations:

    1. Define interfaces:
       - KnapsackItem: { result: EpubResult, tokenCount: number, wordCount: number }
       - Strategy type: 'max-books' | 'max-words' | 'balanced'

    2. Implement knapsackMaxBooks(items, budget):
       - Sort items by tokenCount ascending (shortest first)
       - Iterate through sorted items, add to selection if fits within budget
       - Break when next item doesn't fit (greedy optimization)
       - Return selected items

    3. Implement knapsackMaxWords(items, budget):
       - Sort items by tokenCount descending (longest first)
       - Iterate through sorted items, add to selection if fits within budget
       - Continue through all items (no early break)
       - Return selected items

    4. Implement knapsackBalanced(items, budget):
       - Map items to add ratio: wordCount / tokenCount (words per token)
       - Sort by ratio descending (highest density first)
       - Iterate through sorted items, add to selection if fits within budget
       - Return selected items

    5. Export solveKnapsack(results, budget, tokenizerName, strategy):
       - Filter results: remove items with error property
       - Transform to KnapsackItem[] with tokenCount from tokenizer
       - Filter out items with tokenCount === 0
       - Validate budget: return [] if budget < min(item.tokenCount)
       - Execute appropriate strategy function
       - Return EpubResult[] from selected items

    CRITICAL: Access token count via tokenCounts.find(t => t.name === tokenizerName)?.count ?? 0

    Reference the research pattern for complete implementation. Use O(n log n) sorting for performance.
  </action>
  <verify>
    ```bash
      test -f web/src/lib/knapsack.ts && grep -q "export.*solveKnapsack" web/src/lib/knapsack.ts
    ```
  </verify>
  <done>
    knapsack.ts exports solveKnapsack and three strategy functions (knapsackMaxBooks, knapsackMaxWords, knapsackBalanced)
  </done>
</task>

<task type="auto">
  <name>Create pricing data and cost calculation</name>
  <files>web/src/lib/pricing-data.ts</files>
  <action>
    Create web/src/lib/pricing-data.ts with provider pricing:

    1. Define interfaces:
       - ProviderPricing: { name, inputPrice, outputPrice, pricingUrl }
       - CostEstimate: { provider, inputCost, outputCost, totalCost, pricePerMillion }

    2. Export PROVIDER_PRICING constant (as of 2026-01):
       - openai: { name: 'OpenAI', inputPrice: 2.50, outputPrice: 10.00, pricingUrl: 'https://openai.com/api/pricing/' }
       - anthropic: { name: 'Anthropic', inputPrice: 3.00, outputPrice: 15.00, pricingUrl: 'https://www.anthropic.com/pricing' }
       - google: { name: 'Google', inputPrice: 0.30, outputPrice: 2.50, pricingUrl: 'https://ai.google.dev/gemini-api/docs/pricing' }

    3. Export calculateCost(tokenCount, provider, outputMultiplier = 0):
       - Calculate inputCost: (tokenCount / 1_000_000) * pricing.inputPrice
       - Calculate outputTokens: tokenCount * outputMultiplier
       - Calculate outputCost: (outputTokens / 1_000_000) * pricing.outputPrice
       - Return CostEstimate object

    4. Export getAllCostEstimates(tokenCount):
       - Map through PROVIDER_PRICING keys
       - Call calculateCost for each provider
       - Return CostEstimate[]

    Note: For EPUB processing, all tokens are input tokens (processing text as context). outputMultiplier defaults to 0 but can be set for chat use cases.

    Reference the research pattern for pricing values. Include comment that pricing is as of 2026-01 and should be updated quarterly.
  </action>
  <verify>
    ```bash
      test -f web/src/lib/pricing-data.ts && grep -q "PROVIDER_PRICING" web/src/lib/pricing-data.ts
    ```
  </verify>
  <done>
    pricing-data.ts exports PROVIDER_PRICING constant and cost calculation functions
  </done>
</task>

<task type="auto">
  <name>Create useBudgetCalculator hook</name>
  <files>web/src/hooks/use-budget-calculator.ts</files>
  <action>
    Create web/src/hooks/use-budget-calculator.ts with main calculator hook:

    1. Define interfaces:
       - BudgetCalculatorState: { budget, selectedPreset, tokenizer, strategy }
       - BudgetResult: { selectedBooks, totalTokens, totalWords, remainingTokens, percentUsed }

    2. Define constants:
       - BUDGET_PRESETS: [32000, 128000, 200000]
       - STORAGE_KEY: 'budget-calculator-state'

    3. Export useBudgetCalculator(results: EpubResult[]):
       - Load state from useLocalStorage with defaults
       - Apply useDebounce to state.budget (500ms delay)
       - Calculate result with useMemo:
         * Return empty result if results empty or debouncedBudget <= 0
         * Call solveKnapsack with results, debouncedBudget, state.tokenizer, state.strategy
         * Calculate totalTokens from selected books
         * Calculate totalWords from selected books
         * Return BudgetResult object
       - Create setBudget callback: update budget, set selectedPreset if matches preset
       - Create setPreset callback: update budget and selectedPreset
       - Create setTokenizer callback: update tokenizer
       - Create setStrategy callback: update strategy
       - Calculate isValid with useMemo: budget > 0 and budget >= minTokenCount
       - Return { state, result, isValid, setBudget, setPreset, setTokenizer, setStrategy }

    Use useLocalStorage for persistence. Use useMemo for expensive calculations. Use useCallback for stable function references.

    Reference the research pattern for complete hook implementation. Ensure token count access uses tokenCounts.find() pattern.
  </action>
  <verify>
    ```bash
      test -f web/src/hooks/use-budget-calculator.ts && grep -q "export.*useBudgetCalculator" web/src/hooks/use-budget-calculator.ts
    ```
  </verify>
  <done>
    use-budget-calculator.ts exports useBudgetCalculator hook with state management, knapsack calculation, and validation
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. knapsack.ts exports solveKnapsack and three strategy functions
2. solveKnapsack filters out EPUBs with error property and zero token counts
3. solveKnapsack returns empty array when budget < minimum token count
4. knapsackMaxBooks sorts by tokens ascending (shortest first)
5. knapsackMaxWords sorts by tokens descending (longest first)
6. knapsackBalanced sorts by word-to-token ratio descending
7. pricing-data.ts exports PROVIDER_PRICING with OpenAI, Anthropic, Google
8. calculateCost returns CostEstimate with inputCost, outputCost, totalCost
9. getAllCostEstimates returns CostEstimate[] for all providers
10. useBudgetCalculator hook manages state, calculates selection, and validates budget
</verification>

<success_criteria>
1. Knapsack algorithms select EPUBs within budget constraint for all three strategies
2. Max Books strategy maximizes book count by selecting shortest books
3. Max Words strategy maximizes total word count by selecting longest books
4. Balanced strategy balances count and words by selecting high word-to-token ratio books
5. Algorithms return empty selection when budget is insufficient
6. Pricing data has accurate costs for OpenAI, Anthropic, Google (as of 2026-01)
7. Cost calculation functions return properly formatted CostEstimate objects
8. useBudgetCalculator hook memoizes calculations and only recalculates on input changes
</success_criteria>

<output>
After completion, create `.planning/phases/08-token-budget-calculator/08-02-SUMMARY.md` with summary of implementation
</output>
